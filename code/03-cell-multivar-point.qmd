```{r}
#| include: false
.dfToppp <- function(df, marks = NULL) {
    # is this definition of the window actually correct? Do I underestimate it?
    pp <- spatstat.geom::as.ppp(data.frame(x = df$x, y = df$y), W = spatstat.geom::owin(c(min(df$x) - 1, max(df$x) + 1), c(min(df$y) - 1, max(df$y) + 1)))
    # set the marks
    spatstat.geom::marks(pp) <- factor(df[[marks]])
    return(pp)
}

.speToDf <- function(spe) {
    df <- data.frame(x = SpatialExperiment::spatialCoords(spe)[, 1], y = SpatialExperiment::spatialCoords(spe)[, 2])
    df <- cbind(df, colData(spe))
}

plotMetricPerFov <- function(metric_df, theo = FALSE, correction = NULL, x = NULL, image_id = NULL) {
    p <- ggplot(metric_df, aes(x = .data[[x]], y = .data[[correction]], group = factor(image_id), colour = factor(ID))) +
        geom_line() +
        facet_wrap(~ID) +
        theme_minimal() +
        theme(legend.position = "none") +
        labs(title = paste0(metric_df$fun, " metric for ", unique(metric_df$selection)))
    if (theo == TRUE){
      p <- p + geom_line(aes(x=.data[[x]],y=theo),linetype = "dashed", color = "black")
    }

    return(p)
}
```


```{r}
#| include: false
# extractMetric
extractMetric <- function(df, selection, fun, marks = NULL, r_seq = NULL, by = NULL) {
    pp <- .dfToppp(df, marks = marks)
    meta_data <- df[, by] %>% unique()
    pp_sub <- subset(pp, marks %in% selection, drop = TRUE)
    # small quality control to only consider pp that have more than 100 points per
    # fov and more than one unique mark and that each mark has more than one point
    if (
      spatstat.geom::npoints(pp_sub) > 2 &&
        ((length(unique(spatstat.geom::marks(pp_sub))) > 1 && sum(table(pp_sub$marks) > 2) > 1) || 
        length(selection) == 1)
      ) {
        # TODO: Here I just fix the r values in the range between 0 and 500 to have
        # the same values to compare against in the library fda - that is not ideal
        print("case1")
        metric_res <- do.call(fun, args = list(X = pp_sub, r = r_seq))
    }
    # SG: this handles the case when we do cross functions for the same type
    else if (spatstat.geom::npoints(pp_sub) > 2 &&
        length(unique(selection)) == 1 && 
        length(selection) > 1) {
      print("case2")
      metric_res <- do.call(fun, args = list(X = pp_sub, selection[1], selection[2], r = r_seq))
    }
    # SG: When there are no cells of one type this will construct a dummy metric_res similar to the case of when a non-cross function is calles in a fov where there are no cells (e.g "Ependymal cells" in fov 0.21)
    else {
      print("edge case")
      metric_res <- data.frame(r = r_seq, fun = fun, theo = NA, 
                               border = NA, trans = NA, iso = NA, 
                               row.names = seq(1:length(r_seq)))
      }

    metric_res$image_id <- df$image_number %>% unique() 
    metric_res <- cbind(metric_res, meta_data)
    metric_res$npoints <- spatstat.geom::npoints(pp_sub)
    centroid <- spatstat.geom::centroid.owin(pp_sub$window)
    metric_res$centroidx <- centroid$x
    metric_res$centroidy <- centroid$y
  
    return(metric_res)
}

calcMetricPerFov <- function(
        spe, selection, subsetby = NULL, fun, marks = NULL,
        r_seq = NULL, by = NULL, ncores = 1) {
    # future::plan(multisession, gc = TRUE, workers = ncores)
    df <- .speToDf(spe)
    df_ls <- split(df, df[[subsetby]])
    metric_df <- parallel::mclapply(df_ls, function(df_sub) {
        metric_res <- extractMetric(
            df = df_sub, selection = selection,
            fun = fun, marks = marks, r_seq = r_seq, by = by
        ) %>% as.data.frame()
        return(metric_res)
    }, mc.cores = ncores) %>% bind_rows()
    # store metadata of the calculation in the dataframe
    metric_df$ID <- paste0(metric_df[[by[1]]], "|", metric_df[[by[2]]])
    metric_df$fun <- fun
    metric_df$selection <- paste(selection, collapse = " and ")
    return(metric_df)
}
```


```{r}
#| include: false
# This function could be easily added to the calcMetricPerFov via a check of the length of the selection.
calcCrossMetricPerFov <- function(spe,
                                  selection,
                                  subsetby = NULL,
                                  fun,
                                  marks = NULL,
                                  r_seq = NULL,
                                  by = NULL,
                                  ncores = 1) {
  
  # This creates a grid with all possible 2 way combinations
  l <- apply(expand.grid(selection, selection), 1, function(x) {
    return(c(x[1], x[2]))
  }) |> t()
  
  # calculate the metric per FOV
  res_l <- apply(l, 1, function(x)
    calcMetricPerFov(
      spe,
      x,
      subsetby,
      fun,
      marks,
      r_seq,
      by,
      ncores
    ))
  
  # Bind the data and return
  return(bind_rows(res_l))
}
```

```{r}
#| include: false
# I think it makes sense to have this as a spearate function because it will produce a very different output from plotMetricPerFOV
plotCrossMetricPerFov <- function(metric_df,
                                  theo = NULL,
                                  correction = NULL,
                                  x = NULL,
                                  image_id = NULL,
                                  ID = NULL) {
  # Find all unique samples
  samples <- metric_df[[image_id]] |> unique()
  
  #  Creates a nXn plot of the cross metrics per sample
  plotCrossFOV <- function(sub_fov, theo, correction, x, image_id) {
    #  Apply plot metric function for each combination
    lp <- lapply(unique(sub_fov$selection), function(sel)
      plotMetricPerFov(sub_fov[sub_fov$selection == sel, ], theo, correction, x, image_id))
    #  Count number of marks
    nMarks <- length(unique(sub_fov$selection))
    # Wraps the plot in an nXn grid
    p <- wrap_plots(lp, ncol = sqrt(nMarks)) +
      plot_layout(guides = "collect") &
      theme(legend.position = 'bottom')
    return(p)
  }
  
  # Applies the function abouve to all samples
  res_p <- lapply(samples, function(fov) {
    sub_fov <- subset(metric_df, sample_id %in% fov)
    return(plotCrossFOV(sub_fov, theo, correction, x, image_id))
  })
    
    return(res_p)
}
```

# Discrete Marks

{{< include theory/01-theory-point.qmd >}}

# Multitype point process

```{r}
sub <- spe[, spe$sample_id == "0.01"]
(pp <- .ppp(sub, marks = "cluster_id"))
```


## Multitype and Multivariate viewpoint

A pattern with multiple type of points, e.g. cell types, can be seen in different ways. One the one hand, the **multitype approach** assumes that the points $x$ were recorded together with with their labels $m$ and that they were generated at the same time. The locations and labels therefore have a joint distribution $P(X,M)$. On the other hand one can assume that the pattern with multiple types of points is a combination of several distinct point patterns, one for each type of point. This is the **multivariate approach** and the different point patterns $A$ and $B$ form a joint distribution $P(A,B)$. To test if the labels depend on the location one can assume the following null hypotheses [@baddeleySpatialPointPatterns2015, pp. 565-567]:

- complete spatial randomness and independence (CSRI): the points are distributed at random; the type of each points is randomly allocated; independence between points of different types; allocation of the types independently of the other points and of its location.
- random labeling: each point is assigned a type at random independently of its location
- independence of components:  the points of different types are independent of each other.

Apart from CSRI is is also important for the analysis if we can assume stationarity, i.e. the statistical properties of the point pattern do not change in the window.

For simplicity, we will focus on three cell types of our point pattern: Ependymal, OD Mature and Microglia. This is appropriate if we assume that the point processes are independent. We could also assume that they come from the same process. In this case we have to check the stationarity assumption of the pattern.

```{r}
marks(pp) <- factor(marks(pp))
selection <- c('OD Mature', 'Ependymal', 'Microglia')

pp_sel <-  subset(pp, marks %in% selection, drop = TRUE)

spe_sel <- spe[, spe$sample_id == "0.01" &  spe$cluster_id %in% selection]

```


```{r}
#| fig-width: 7.5
#| fig-height: 7.5
pp_sel |> as.data.frame() |> 
  ggplot(aes(x = x, y = y, color = marks)) +
  geom_point() +
  theme_minimal() +
  coord_fixed() +
  scale_color_brewer(palette = "Set1")

```

The summary of `pp` (point pattern) object returns general properties, plus intensities, combined and per mark type.

```{r}
summary(pp)
```

To get the overall intensity the individual intensities can be summed up. Assuming that the the multitype process is first order stationary (i.e. each sub-process is stationary) the individual intensities sum up to the intensity of the unmarked point process [@baddeleySpatialPointPatterns2015, pp. 574ff.].

```{r}
sum(intensity(pp)) == intensity(unmark(pp))
```

The stationarity assumption is not appropriate in all cases. To assess first-order stationarity visually, we can plot the kernel density estimates per type.

```{r}
#| fig-width: 7.5
#| fig-height: 7.5
ppls <- split(pp_sel) # split by mark
plot(density(ppls))
```

Ependymal and OD Mature cells are cleary inhomogeneous, while for Microglia cells it is not so clear and we could assume homogeneity, especially as there are no cells in the bottom middle of the window.

<!-- If we plot all estimated intensities on the same scale, the low intensity of Microglia becomes more apparent. -->

<!-- ```{r} -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 10 -->
<!-- plot(density(ppls), zlim = c(0, max(density(ppls)))) -->
<!-- ``` -->

<!-- [MR: just to be efficient on space, perhaps just show one of the density plots. But also, density was already discussed in the previous vignette. So, maybe we can also remove it?] -->

To further inverstiagte the spatial arrangement of the different cell types we can calculate the relative risk, i.e., the probability of observing a given celltype at a given location. It is calculated using the function `relrisk`. The bandwidth for smoothing is calculated with `bw.relrisk` and might need to be adjusted [@baddeleySpatialPointPatterns2015, pp. 577-583].

```{r}
#| fig-width: 7
#| fig-height: 7
#| eval: false
#| include: false
rp <- relrisk(pp_sel,se=TRUE)
plot(rp$estimate, zlim = c(0, max(rp$estimate)))
```

```{r}
#| eval: false
#| include: false
im_sum <- im.apply(rp$estimate,sum)
im_sum <- signif(im_sum,9)
all(im_sum==1)
```

The `relrisk` function further gives us the dominant mark for different regions of the tissue of interest. This could be interesting in the annotation of spatial domains. It indicates at each location, which cell type is most likely to occur. 

```{r}
#| fig-width: 10
#| fig-height: 10
rpd <- relrisk(pp_sel, diggle = TRUE)
dom <- im.apply(rpd, which.max)
dom <- eval.im(factor(dom, levels = seq_along(levels(unique(marks(pp_sel)))),
                      labels = levels(unique(marks(pp_sel)))))
plot(dom,las=2,main="Dominant mark")
```

<!-- # Random labeling -->

<!-- A test of segregation of marks can be performed with `segregation.test`. It is based on the assumption of random labeling and the computed test statistic measures the similarity of the distribution of marks. The randomization is done by permuting the marks of the points while keeping the locations constant [@baddeleySpatialPointPatterns2015]. -->

<!-- ```{r} -->
<!-- #| warning: false -->
<!-- segregation.test(pp,nsim=19) -->
<!-- ``` -->

<!-- In this case, there is clear indication that the labeling of marks is not random. For more about random labeling check the part in umarked about local scaling. -->

<!-- #TODO: shall we move this part to umarked as well, it goes together with the hotspot analysis -->

<!-- [MR: here same thing, we need a little bit of explanation of what this tells you .. it's basically that the points are non-randomly distributed? If so, it doesn't add that much maybe.] -->

 <!-- <!-- # Measures of spatial segregation -->

<!-- [SG: I leave them out for now, I'm not sure how much we gain from them. I think Dixon test is more informative] -->

<!-- The package `seg` implements different measures of spatial segregation, which quantify two distinct aspects [@osullivanSegMeasuringSpatial2019]. The first describes the evenness versus clustering, which is independent of the overall composition of a sample and describes the distribution of individuals. The second describes isolation versus exposure, which will depend on the composition and describes the degree to which different groups are isolated from or exposed to one another. -->

<!-- Spatial segregation measures developped by [@reardonMeasuresSpatialSegregation2004]. -->

<!-- The segregation measures, D, R and H, measure spatial evenness, while P measures the spatial exposure, as follows: -->

<!-- - The dissimilarity index (D) describes how different the composition of a local environment is [MR: should we define what a 'local environment' is? Is it like a quadrat?], on average, from the composition of the total population. It ranges from 0 to 1, where 0 indicates perfect integration, and 1 indicates complete segregation. -->
<!-- - Relative diversity (R) is a measure of how much less diverse each local environments is, on average, compared to the total population. It ranges from 0 to 1, where 0 indicates perfect integration, and 1 indicates complete segregation. -->
<!-- - The information theory index (H) is a measure of how much less diverse local environments are, on average, compared to the entire sample. It can be interpreted as a measure of the variation in diversity of each local environment. It ranges from 0 to 1, where 0 indicates no segregation, and 1 indicates maximum possible segregation, i.e., all subjects in each local environment belong to one group only. -->
<!-- - The spatial exposure index (P) of mark m to mark n represents the average percentage of mark n in the local environments of each member of group m; it ranges from 0 (no exposure) to 1 (maximal exposure). -->


<!-- ```{r} -->
<!-- # create an indicator matrix -->
<!-- mm <- model.matrix(~0 + marks(pp_sel)) -->
<!-- colnames(mm) <- gsub("marks(pp_sel)", "", -->
<!--                      colnames(mm), fixed = TRUE) -->

<!-- #[MR: slightly more compact representation above] -->

<!-- spseg(pp_sel, -->
<!--       data = mm, -->
<!--       smoothing = 'kernel') -->
<!-- ``` -->

<!-- How to interpret the spatial exposure index P? Let's look at the documentation of the function. -->

<!-- From `help(spseg)` -->

<!-- > The exposure/isolation index, P, is presented in a matrix form. The spatial exposure of group ‘m’ to group ‘n’ is located in the row ‘m’ and column ‘n’ of the matrix. The matrix is rarely symmetric in practice so the spatial exposure index should be interpreted with care. The spatial isolation index values are given in the diagonal cells of the matrix; cell value at (m, m) indicates the degree of spatial isolation for group ‘m’ for example. -->

<!-- [MR: I think we shouldn't just quote the docs .. we should write this in our own words. Can we write a bit about the context of these 3 cell types?] -->

<!-- ## Spatial Proximity -->

<!-- An index of Spatial Proximity, developed by [@whiteMeasurementSpatialSegregation1983] represents the degree of segregation. A value of 1 indicates evenness in the sample, and values greater than 1.0 indicate clustering. If the index value is smaller than one, it indicates an unusual form of segregation (i.e., some groups are closer to other groups). It compares the average distance between members of one group with that between all individuals, irrespective of group assignment. It may change depend on the definition of distance. -->

<!-- ```{r} -->
<!-- # Index of spatial proximity -->
<!-- paste0('Index of spatial proximity: ', -->
<!-- isp(pp_sel, -->
<!--     data = mm) %>% round(3))  -->
<!-- ``` -->

<!-- [MR: because it's just a number, we might need a comparative example. From the description above, it indicates clustering. But how to know what contributes to that? Both Ependymal and OD Mature contribute.] -->

# Correlation and spacing

<!-- ## Distances and nearest neighbors -->

<!-- Investigating the kth nearest neighbor distance between points for all combinations of marks can be done as follows: -->

<!-- ```{r} -->
<!-- d <- nndist(pp_sel, k = 2, by = marks(pp_sel)) -->
<!-- (a <- aggregate(d, by = list(from=marks(pp_sel)), min)) -->
<!-- ``` -->

<!-- Another option is to either use the `K` nearest neighbors or count the number of points of a given type with a distance closer than `R`. Both can be done with the function `marktable`, where the argument `R` stands for the neighborhood radius and `N` for number of neighbors. -->

<!-- ```{r} -->
<!-- mt <- marktable(pp_sel,N = 5,collapse = TRUE) -->
<!-- signif(mt/rowSums(mt),2) -->

<!-- mt <- marktable(pp_sel,R = 10,collapse = TRUE) -->
<!-- signif(mt/rowSums(mt),2) -->

<!-- ``` -->

<!-- Additionally the function `markstat` can be used to calculate more complicated expressions than just the sum. -->

<!-- ## Nearest neighbor correlations -->

<!-- A overall correlation between marks [MR: what is the interpretation of overall correlation b/w marks when marks are discrete? Or maybe I misunderstand what is meant by correlation here.] can be calculated with `nncorr`. It returns two values: `unnormalised`, which is the probability that a point and its nearest neighbor have the same type and `normalised`, which divides the unnormalised probability by the probability of random labeling. So a value close to 1 indicates random labeling. A value much less than 1 means neighboring point are often of the same type.  -->

<!-- ```{r} -->
<!-- nncorr(pp_sel) -->
<!-- ``` -->

<!-- [MR: is this multivariate?] -->

<!-- <!-- The R package `spdep` (https://cran.r-project.org/package=spdep) contains many functions to calculate statistics based on nearest neighbors. -->

## Nearest neighbourhood contingency

To further investigate the spatial distribution of the marks we can investigate the nearest neighbourhood of each cell type. One possibility is to work with nearest neighborhood contingency tables developed by [@dixonNearestneighborContingencyTable2002]. The statistical tests are implemented in the R package `dixon` [@delacruzMetodosParaAnalizar2008]. 

The measure of segregation $S$ is defined in [@dixonNearestneighborContingencyTable2002] as 

$$S_{i,j}= \frac{\log[(N_{i,j}/(N_i−N_{i,j})]}{[(N_i−1)/(N−N_i)]}$$
where $N_i$ is the number of individuals $i$, $N_{i,j}$ is the number of individuals of type $i$ with a nearest neighbor of type $j$, and $N$ is the total number of individuals. 

A value of $S=0$ is consistent with random labeling. A value larger than 0 indicates that the two types are more segregated than expected by chance, the larger the value the more segregated. Note that segregated means that it is more likely to expect a neigbour of type $j$ than by chance. In the case that the neigbour is of the same type this is equivalent to "clustering". On the other hand if $S<0$ it indicates that type $j$ is less likely to be a neigbour than by chance. The P-values are calculated using expected numbers of nearest neighbors under the null hypothesis of random labeling using a Monte-Carlo simulation and assumes an asymptotic $\chi^2$ distribution.


```{r}
#| echo: true
#| message: false
out <- dixon(as.data.frame(pp_sel), nsim = 99)
out$tablaZ %>% 
  arrange(desc(abs(`Z `))) %>%
  select(-`  p-val.Nobs`)
```

In this table we see that most Ependymal cells are very clustered, while Microglia are more evenly distributed. Further we see that it is less likely to find a Ependymal cells next to a OD mature cells than by chance. 

OD Mature cells show this interesting characteristic that they are clustered in some parts of the tissue and more evenly distributed in other parts of the structure. This characteristic is not visible in the table. The statistic also considers only the nearest neighbour and ignores neighbours that are further away. 

## Summary functions for pairs of types

Similar to the simple case without marks, it is possible to estimate summary functions. In particular, summary functions *between* different marks can be calculated. Note that the canonical functions assume that the multi-type process is stationary.

### Cross K-function

The cross K-function is a summary function that measures the average number of points of type `j` within a distance `r` of a point of type `i`. The formula is given by: 

$$
K(r) = \frac{1}{\lambda_j} \mathbb{E} [t(u,r,X^{j})|u \in X^{i}],
$$

where $X^{i}$ is the point pattern of type $i$ and $t(u,r,X^{j})$ is the number of points of type $j$ in a circle of radius $r$ around $u$ [@baddeleySpatialPointPatterns2015, pp. 594-595]. It is important to remember that the homogeneous cross K-function assumes that the multitype process is stationary. If this is not the case, there is a risk in misinterpreting the results. The problem is the confounding between clustering and inhomogeneity, c.f. [@baddeleySpatialPointPatterns2015, pp. 151-152] 

First, we plot an overview over the cross K function for the different types. As we have seen before the assumption of stationarity might be not valid. We will therefore use the inhomogeneous version of the cross K function.

```{r}
#| fig-width: 15
#| fig-height: 10

resCross <- calcCrossMetricPerFov(
  spe,
  selection = c("OD Mature", "Ependymal", "Microglia"),
  subsetby = 'sample_id',
  fun = 'Kcross.inhom',
  marks = 'cluster_id',
  r_seq = seq(0, 500, length.out = 100),
  by = c('Animal_ID', 'sample_id')
)

resCross <- subset(resCross, sample_id %in% c('-0.09', '0.01', '0.21'))
plotCrossMetricPerFov(resCross, theo = TRUE, correction = "iso", x = "r", image_id = 'sample_id')
```

<!-- [MR: given that these plots are somewhat redundant .. like, the upper diagonal is basically the same as the lower diagonal, maybe it's worth having a more compact representation, e.g., one plot for each cell type, with multiple lines plotted? Also, doesn't the Ependymal-Ependymal function appear to be less than the CSR line? Is that the opposite of what we've seen before?] -->

The diagonal of the imhomogeneous cross K-function plot shows the K-function for the different marks (indication of Poisson or non-Poisson point processes). Off-diagonal panels give indication of independence of points when the number of points follows the expected K-function but does not imply that the individual marks follow a Poisson process. If the types are independent, they are also uncorrelated.

In the example above, assuming that the process is inhomogeneous, the Ependymals cells appear to be regularly spaced, which seems counter intuitive. However, this is the result of the pattern being inhomogeneous with spatially varying intensity. When accounting for this, the pattern is more regular than expected under an inhomogeneous point process. The estimation of the inhomogeneous cross functions is not straightforward and results change based on the estimation of the local intensity and the edge correction, c.f. [@baddeleySpatialPointPatterns2015, p. 605].

Let's focus a bit more on the relationship between Ependymal and the other two cell types. We will also calculate confidence intervals for the different cross K-functions. We have already seen that our dataset most likely does not satisfy the assumption of stationarity. For this reason, we will calculate further calculate the inhomogeneous cross K-function.

> TODO: implement confidence bands in `spatialFDA`

```{r}
#| echo: true
#| message: false
#| results: hide
plotCrossMetric <- function(ppp, fun, from, to, edgecorr){
  lce <- lohboot(ppp, fun, from = from, to = to)
  p <- ggplot(lce, aes(x = r, y = .data[[edgecorr]])) +
    geom_line(size = 1) +
    geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.25)+
    geom_line(aes(x = r, y = theo), linetype = "dotted", size = 1) +
    geom_line() +
    labs(title = attributes(lce)$yexp) +
    theme_minimal()
  return(p)
}

p_epen_od <- plotCrossMetric(pp_sel, "Kcross.inhom", 
                             "Ependymal", "OD Mature", "iso")
p_epend_micro <- plotCrossMetric(pp_sel, "Kcross.inhom", 
                                 "Ependymal", "Microglia", "iso")

```
```{r}
# fig-width: 10
# fig-height: 10
p_epen_od + p_epend_micro
```

Remember that the dashed line represents the assumption of a multitype Poisson process. If the line lies above the dotted line, there is indication of clustering while if the line is below the dotted line there is indication of repulsion. In the plot above we can see that there is indication of clustering between Ependymal and OD Mature cells while there is indication of repulsion between Ependymal and Microglia cells.

### Cross L-function 
Alternatively the L cross function with similar interpretation can be calculated using the `Lcross` function [@baddeleySpatialPointPatterns2015, pp. 596ff].

```{r}
#| fig-width: 15
#| fig-height: 10

resCross <- calcCrossMetricPerFov(
  spe,
  selection = c("OD Mature", "Ependymal", "Microglia"),
  subsetby = 'sample_id',
  fun = 'Lcross.inhom',
  marks = 'cluster_id',
  r_seq = seq(0, 500, length.out = 100),
  by = c('Animal_ID', 'sample_id')
)

resCross <- subset(resCross, sample_id %in% c('-0.09', '0.01', '0.21'))
plotCrossMetricPerFov(resCross, theo = TRUE, correction = "iso", x = "r", image_id = 'sample_id')
```

### Mark connection function

The mark connection function is the cross pair-correlation function, i.e. the generalization of the pair correlation function to a multitype point processes, divided by the unmarked pair-correlation function. It can be interpreted as the conditional probability that two points a distance $r$apart have labels of type A and of type B, given the presence of those points [@baddeleySpatialPointPatterns2015, pp. 596-597]. 

```{r}
#| fig-width: 15
#| fig-height: 10
plotCrossAll(pp_sel, "markconnect", "iso") + 
  scale_y_continuous(limits = c(0, 1))
```
```{r}
#| fig-width: 15
#| fig-height: 10
plot(markconnect(pp_sel, "OD Mature", "OD Mature"))
```


```{r}
#| fig-width: 15
#| fig-height: 10
plot(alltypes(pp_sel, fun = "markconnect"))
```
```{r}
calcMetricPerFov(
  spe_sel,
  selection = c("OD Mature", "OD Mature"),
  subsetby = 'sample_id',
  fun = 'markconnect',
  marks = 'cluster_id',
  r_seq = seq(0, 500, length.out = 100),
  by = c('Animal_ID', 'sample_id')
)
```

```{r}
#| fig-width: 15
#| fig-height: 10

resCross <- calcCrossMetricPerFov(
  spe_sel,
  selection = c("OD Mature", "Ependymal", "Microglia"),
  subsetby = 'sample_id',
  fun = 'markconnect',
  marks = 'cluster_id',
  r_seq = seq(0, 500, length.out = 100),
  by = c('Animal_ID', 'sample_id')
)

#resCross <- subset(resCross, sample_id %in% c('-0.09', '0.01', '0.21'))
plotCrossMetricPerFov(resCross, theo = TRUE, correction = "iso", x = "r", image_id = 'sample_id')
```

```{r}
#| fig-width: 15
#| fig-height: 10

resCross <- calcCrossMetricPerFov(
  spe,
  selection = c("OD Mature", "Ependymal", "Microglia"),
  subsetby = 'sample_id',
  fun = 'markconnect',
  marks = 'cluster_id',
  r_seq = seq(0, 500, length.out = 100),
  by = c('Animal_ID', 'sample_id')
)

resCross <- subset(resCross, sample_id %in% c('-0.09', '0.01', '0.21'))
plotCrossMetricPerFov(resCross, theo = TRUE, correction = "iso", x = "r", image_id = 'sample_id')
```

<!-- [MR: wondering .. should these above all be put on the same scale? And, same question as above. Could we think about a more compact representation?] -->

The dashed lines indicate expected values under random labeling. The values measure dependence (or association) between the different labelled points. Positive values indicate that nearby points are more likely to have different types than expected by chance. This positive association between different cell types does not necessarily imply dependence, as it could be influenced by a negative association between cells of the same type, as it it could be the case for the Microglia cells. Furthermore, as the calculation is based on the $K$ function, the mark connection function assumes homogenity.

### Cross F-function (empty space function), cross G-function (Nearest-neighbor function) and cross J-function

The cross F-function is the cumulative distribution function of the distance from a location to the nearest point of the same type. For each type $i$, it is defined as:

$$F_i(r) = \mathbb{P}\{d(u,X^{i}\leq r\}.$$

The cross G-function is the cumulative distribution function of the distance from a location to the nearest point of another type and is defined as:

$$G_{ij}(r) = \mathbb{P}\{d(x,X^{(j)} \setminus u \leq r \mid X^{(i)} \ \text{has a point at u}).$$

If the points are independent of each other, the G and F function are identical. Both assume that the process is stationary. There are inhomogenous alternatives, in case the intensity is varying. Then we only assume correlation stationarity.

There exists a difference in the interpretation of the theoretical values of the K-cross and the G-cross function. For the K-cross, the theoretical value indicates independence between marks while for the G-cross the theoretical value is consistent with the assumption that the points of type `j` are Poisson in addition to being independent of the points of type $i$ [@baddeleySpatialPointPatterns2015, p. 597 ff].

The cross J-function is defined as:

$$J_{ij}(r) = \frac{1-G_{ij}(r)}{1-F_{j}(r)}$$

and summarizes the interpoint dependence between type $i$ and $j$. Under the hypothesis of independent components, i.e., that the point processes of each type are independent, the G-function is equivalent to the F-function and the J-function is equal to 1 [@baddeleySpatialPointPatterns2015, p. 597 ff]. 

<!-- ### Cross J-function  -->

<!-- The value of 1 is consistent with CSR and independence between different points. -->

<!-- ```{r} -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 10 -->
<!-- jc <- alltypes(pp_sel, Jcross) -->
<!-- plot(jc) -->
<!-- ``` -->

### Dot functions

For each K-, G- and J- function, there also exist *dot* functions, which measure distances from points of one type to points of any type. These functions allow us to measure the dependence of one mark with all other marks at once.  For expample, the K-dot function represents the expected number of an other point within distance $r$ of a typical point of type $i$ [@baddeleySpatialPointPatterns2015, p. 600 ff]. 

```{r}
#| fig-width: 8
#| fig-height: 4
plotCrossAll(pp_sel, "Kdot.inhom", "iso")
```

```{r}
#| fig-width: 15
#| fig-height: 10

resCross <- calcMetricPerFov(
  spe,
  selection = c("OD Mature", "Ependymal", "Microglia"),
  subsetby = 'sample_id',
  fun = 'Kdot',
  marks = 'cluster_id',
  r_seq = seq(0, 500, length.out = 100),
  by = c('Animal_ID', 'sample_id')
)

resCross <- subset(resCross, sample_id %in% c('-0.09', '0.01', '0.21'))
plotMetricPerFov(resCross, theo = TRUE, correction = "iso", x = "r", image_id = 'sample_id')
```

The dot functions are useful summary statistics to analyse the dependence of one mark with all other marks. 

## Summary function within and between types

In our original dataset, we have a large number of different marks. We picked three: OD mature, Ependymal and Microglia for illustrative purposes. An alternative to looking at all cross summary function combinations, it is possible to compare between and within types [@baddeleySpatialPointPatterns2015].

### Mark equality function

The Mark or Type Equality function for a stationary multitype point process measures the correlation between types of two points separated by distance r. It is the sum of the mark connection function of all pairs of points of the same type.

If k < 1, points at distance r are less likely than expected to be of the same type. If > 1, they are more likely to be of the same type. The value 1 indicates a lack of correlation [@baddeleySpatialPointPatterns2015, p. 603 ff].

```{r}
#| fig-width: 5
#| fig-height: 5
plotMarkCorr <- function(pp, edgecorr = "iso") {
    me <- markcorr(pp)
    ggplot(me, aes(x = r, y = .data[[edgecorr]])) +
        geom_line(size = 1) +
        geom_line(aes(x = r, y = theo), linetype = "dotted", size = 1) +
        geom_line() +
        labs(title = attributes(me)$yexp) +
        theme_minimal()
}

plotMarkCorr(pp_sel)
```

We can see that in our dataset that it the more likely it is to find points of the same type at shorter distances. The curve never crosses the dashed line at 1, which means that it is generally more likely to find points of the same type at any distance than expected by chance.

<!-- ### I-function  -->

<!-- ```{r} -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 10 -->
<!-- ic <- Iest(pp_sel) -->
<!-- plot(ic) -->
<!-- ``` -->

<!-- ## Summary functions for non stationary processes -->

<!-- The cross and dot functions described above assume a underlying stationary point process. If this assumption is not given, the interpretation of the result might be incorrect. -->

<!-- The inhomogeneous equivalents of the described functions require the different intensities as inputs in `spatstat`. If they are not given the intensities are estimated using kernel smoothing.   -->

<!-- ### Inhomogeneous L-function -->
<!-- ```{r} -->
<!-- plot(Lcross.inhom(pp_sel, "Microglia", "OD Mature", sigma=bw.diggle(pp_sel))) -->
<!-- plot(Lcross.inhom(pp_sel, "Microglia", "OD Mature", sigma=bw.relrisk(pp_sel))) -->

<!-- Lcross.inhom(pp_sel, "Microglia", "OD Mature") %>% plot() -->
<!-- ``` -->

# Tests of randomness and independence

In a multitype point process, there are usually two interesting hypotheses: 

- random-labeling hypothesis: the allocation of labels to the points is random
- independent component hypothesis: there is independence between different type of points

If both statments are correct, the point pattern is considered to be complete spatially random and independent (CSRI), the marked analog to complete spatial randomness (CSR) [@baddeleySpatialPointPatterns2015, p. 605 ff].

## Testing random labelling

The random labeling test is most logical when the marks represents its status, which is not most appropriate assumption when considering cell types. Testing for random labeling can be done using permutation test, in which the labels are randomly permuted. Random labeling can be assumed if the permuted datasets are statistically equivalent to the original dataset [@baddeleySpatialPointPatterns2015, p. 609 ff].

## Testing the indepenence of components assumption

The i-to-j functions are useful to test the independence of different subprocesses. If the processes of type i and j are independent, then
$K_{ij} = \pi r^2, G_{ij}(r) = F_{j}(r),  J_{ij}(r) \equiv 1$. Alternatively, randomization tests can be used in which simulated patterns from the dataset are generated and randomly split into subpatterns. These are then compared to the null hypothesis in which all subpatterns should be statistically equivalent to the original. However, this approach assumes stationarity and there is a need to handle edge effects [@baddeleySpatialPointPatterns2015, p. 606 ff].

```{r}
#| echo: true
#| message: false
#| results: hide

plotEnvCross <- function(pp, i, j, fun, nsim = 39, radius = 150, global = FALSE){
  pp_scaled <- rescale(pp)
  E1 <- envelope(pp_scaled, fun, nsim=nsim, i=i, j=j,
                 simulate=expression(rshift(pp_scaled, radius = radius)), global = global)
  p <- ggplot(E1, aes(x = r, y = .data[["mmean"]])) +
    geom_line(size = 1) +
    geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.25)+
    geom_line(aes(x = r, y = obs), linetype = "dotted", size = 1) +
    geom_line() +
    labs(title = attributes(E1)$yexp) +
    theme_minimal()
  return(p)
}

pEnv <- plotEnvCross(pp_sel, fun = "Kcross.inhom", 
                     "Ependymal", "OD Mature", nsim = 39, radius = 150)
```

```{r}
#| fig-width: 5
#| fig-height: 5
pEnv
```

```{r}
#| fig-width: 5
#| fig-height: 5
plotEnvCross(pp_sel, fun = "Kcross.inhom", 
             "Ependymal", "OD Mature", nsim = 39, radius = 150, global = TRUE)
```

We have indication that the independence-of-components assumption should not be rejected. Therefore, we conclude that Ependymal and OD Mature cells are independent.

# Assuming stationarity of the total pattern

As outlined above, the homogeneous cross correlation and spacing functions assume stationarity, whereas the inhomogeneous functions only assume correlation stationarity. First-order stationarity is not given in our dataset, when we look at the different patterns individually. However, using the total (unmarked) pattern, we could assume first-order stationarity, since the intensity is the same across the pattern.

```{r}
plot(density(unmark(pp)))
```

Let's look at the homogeneous cross K-function.

```{r}
#| fig-width: 15
#| fig-height: 10
plotCrossAll(pp_sel, "Kcross", "iso")
```

The result is different from the previous analysis. The Ependymal cells now appear to be clustered. This is because stationarity assumes that Ependymal cells could theoretically be present in the total observation window. If this assumption is justified, depends on the context and research question. The interpretation of the results should always be done with the assumption of stationarity or inhomogeneity in mind and should be reported in an analysis.

## Session info

```{r}
#| label: session-info
sessionInfo()
```
