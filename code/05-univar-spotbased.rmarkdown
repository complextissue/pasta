# Preamble

## Dependencies


```{r}
#| label: load-libs
#| message: false
#| warning: false
#| results: hide
source("utils.R")
theme_set(theme_light())
```


## Setup and Preprocessing


```{r}
#| label: load-data
# taken from https://pachterlab.github.io/voyager/articles/visium_10x.html
#spe_vis <- readRDS("../data/spe_spot.rds")
#spe_vis

sfe <- SFEData::McKellarMuscleData(dataset = "full")

sfe <- mirrorImg(sfe, sample_id = "Vis5A", image_id = "lowres")
sfe
sfe_tissue <- sfe[,colData(sfe)$in_tissue]
sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,]

#perform normalisation 
sfe_tissue <- scater::logNormCounts(sfe_tissue)

colGraph(sfe_tissue, "visium") <- findVisiumGraph(sfe_tissue)
```


Given this data from McKellar et al. we choose two genes to analyse henceforth, named _Mdk_ and _Ncl_ [@mckellarLargescaleIntegrationSinglecell2021]. 

---
title: "Theory -- Regular lattices"
---

Spot based data is collected along a regular spaced grid where all sample areas have the same size. Such a grid is also called a regular lattice. In more rigorous terms the data $Y$ is the product of a random process but the sampling locations are fixed along a lattice $D$. The lattice $D$ does not have to regular but in the scope of spot based data it is. The main difference of this type of data in comparison to point patterns is, that the locations of the data are then not results of a stochastic process but rather due to a defined sampling strategy [@zuurAnalysingEcologicalData2007].

The lattice is composed of individual spatial units

$$D = \{A_1, A_2,...,A_n\}$$

where these units are not supposed to overlap

$$A_i \cap A_j = \emptyset \forall i \neq j$$

The data is then a random variable of the spatial unit along the lattice

$$Y_i = Y(A_i)$$

Most lattice data analysis technique build on the concept of neighbours. Therefore, the spatial relationship has to be modelled with e.g. a spatial weigth matrix $W$. There are a lot of ways to define a spatial weigth matrix $W$. Here, the units that are adjacent are specified with a one and the ones that are not adjacent with a zero (binary coniguity matrix)

$$w_{ij} = \begin{cases} 1 \text{ if } A_i \text{ and } A_j \text{ are adjacent}\\ 0 \text{ otw} \end{cases}$$

other options to specify the weight matrix $W$ are mentioned in [@zuurAnalysingEcologicalData2007]. 

---
title: "Theory -- Univariate lattice based analysis"
---

## Global Methods

Global methods give us an overview over the entire field of view and summarize the spatial distribution of the cells (for a given measurement such as gene expression) in a single value. The most common global measures are Moran's I and Geary's C coefficients; these coefficients are a function of the weight matrix and the variables of interest.

In general, a global spatial autocorrelation measure has the form of a double sum over all locations

$$\sum_i \sum_j f(x_i,x_j) w_{ij}.$$

### Global Moran's I coefficient

The global Moran's I [@moranNotesContinuousStochastic1950] coefficient is a measure of spatial autocorrelation, defined as:

$$I = \frac{n}{\sum_i\sum_j w_{ij}} \frac{\sum_i\sum_j w_{ij}(x_i - \bar{x})(x_j - \bar{x})}{\sum_i (x_i - \bar{x})^2}.$$

where $x_i$ and $x_j$ represent the values of the variable of interest at locations $i$ and $j$, $\hat{x}$ is the mean of all $x$ and $w_{ij}$ is the spatial weight between the locations of $i$ and $j$. The expected value is close to $0$ for large $n$ ($\mathbb{E}(I) = -1/(n-1)$), whereas a value higher than indicates spatial auto-correlation. Negative values indicate negative auto-correlation.

### Global's Geary's C coefficient

Geary's $C$ [@gearyContiguityRatioStatistical1954] is a different measure of global autocorrelation and is very closely related to Moran's $I$. However, it focuses on spatial dissimilarity. Geary's $C$ is defined by

$$C = \frac{(n-1) \sum_i \sum_j w_{ij}(x_i-x_j)^2}{2\sum_i \sum_j w_{ij}\sum_i(x_i-\bar{x})^2}$$

where $x_i$ and $x_j$ represent the values of the variable of interest at locations $i$ and $j$, $\hat{x}$ is the mean of all $x$, $w_{ij}$ is the spatial weight between the locations of $i$ and $j$ and $n$ the total numer of locations. The interpretation is opposite to Moran's $I$: a value smaller than $1$ indicates positive auto-correlation whereas a value greater than $1$ represents negative auto-correlation.

### Global Getis-Ord $G$ statistic

The global $G$ [@getisAnalysisSpatialAssociation1992] statistic is a generalisation of the local version (see below) and summarises the contributions of all pairs of values $(x_i, x_j)$ in the dataset. Formally that is


$$G(d) = \frac{\sum_{i = 1}^n \sum_{j=1}^n w_{ij}(d)x_ix_j}{\sum_{i = 1}^n \sum_{j=1}^n x_i x_j} \text{s.t } j \neq i.$$

The global $G(d)$ statistic is very similar to global Moran's $I$. The global $G(d)$ statistic is based on the sum of the products of the datapoints whereas global Moran's $I$ is based on the sum of the covariances. Since these two approaches capture different aspects of a structure, their values will differ as well. A good approach would be to not use one statistic in isolation but rather consider both. 

It is recommended to use binary weights for this calculation. We will use the `spdep` package directly to calculate the global $G$ statistic.

## Local measures

Unlike global measures that give an overview over the entire field of view, local measures report information about the statistic at each location (cell). There exist local analogs of Moran's I and Geary's C for which the global statistic can be represented as a weighted sum of the local statistics. As above, the local coefficients are based on both the spatial weights matrix and the values of the measurement of interest.

### Local Moran's I coefficient

The local Moran's I coefficient [@anselinLocalIndicatorsSpatial1995] is a measure of spatial autocorrelation on each location of interest. It is defined as:

$$I_i = \frac{x_i - \bar{x}}{\sum_{k=1}^n(x_k-\bar{x})^2/(n-1)} \sum_{j=1}^n w_{ij}(x_j - \bar{x})$$

where the index $i$ refers to the location for which the measure is calculated. The interpretation is analogous to the global Moran's I where a value of $I_i$ higher than $\mathbb{E}(I) = -1/(n-1)$ indicates spatial auto-correlation; smaller values indicate negative auto-correlation. It is important to note that, as for the global counterpart, the value of local Moran's I could be a result from both the high or low end of the values. Since we measure and test a large number of locations simultaneously, we need to correct for multiple testing (e.g., using the Benjamini-Hochberg procedure).

### Local Geary's C coefficient

Similar to local Moran's I, there is a local Geary's C [@anselinLocalIndicatorsSpatial1995] coefficient. It is defined as

$$C_i = \sum_{j=1}^n w_{ij}(x_i-x_j)^2$$

The interpretation is analogous to the global Geary's C (value less than $1$ indicates positive auto-correlation, a value greater than $1$ highlights negative auto-correlation).

In this example, we will not plot the local Geary's C coefficient for gene expression but for features that are associated with an individual cell, e.g., the number of counts or the number of genes expressed. For this, the `colDataUnivariate` function is used to calculate the local Geary's C coefficient for such features.

### Local Getis-Ord statistic

The local Getis-Ord $G_i$ [@ordLocalSpatialAutocorrelation1995; @getisAnalysisSpatialAssociation1992] statistic quantifies the weighted concentration of points within a radius $d$ and in a local region $i$, according to:

$$G_i(d) = \frac{\sum_{j \neq i } w_{ij}(d)x_j}{\sum_{j \neq i} x_j}$$

There is a variant of this statistic, $G_i^*(d)$, which is the same as $G_i(d)$ except that the contribution when $j=i$ is included in the term. 

<!-- Importantly, $G_i(d)$ is scale-invariant but not location-invariant, meaning that the subdivision into the $n$ subregions matters for the computation of the local statistic [MR: what does "matters" mean in this sentence?]. -->

### Local spatial heterosceadiscity (LOSH)

The local spatial heteroscedasticity (LOSH) is a measure of spatial autocorrelation that is based on the variance of the local neighbourhood. Unlike the other measures, this method does not assume homoscedastic variance over the whole tissue region. LOSH is defined as:

$$H_i(d) = \frac{\sum_j w_{ij}(d)|e_j(d)|^a}{\sum_j w_{ij}(d)}$$

where $e_j(d) = x_j - \bar{x}_i(d), j \in N(i,d)$ are the local residuals that are subtracted from the local mean. The power $a$ modulates the interpretation of the residuals ($a=1$: residuals are interpreted as absolute deviations from the local mean; $a=2$: residuals are interpreted as deviations from the local variance).

The LOSH should be interpreted in combination with the local Getis-Ord $G_i^*$ statistic. The $G_i^*$ quantifies the local mean of the variable of interest, while $H_i$ quantifies the local variance. This table provided by Ord and Getis [@ordLocalSpatialHeteroscedasticity2012] summarizes the interpretation of the combination of $G_i^*$ and $H_i$.

|                     | high $H_i$                                                                    | low $H_i$                                                                                                                      |
|---------------------|-------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------|
| large $\|G_i^*\|$   | A hot spot with heterogeneous local conditions                                | A hot spot with similar surrounding areas; the map would indicate whether the affected region is larger than the single “cell” |
| small $ \|G_i^*\| $ | Heterogeneous local conditions but at a low average level (an unlikely event) | Homogeneous local conditions and a low average level                                                                           |




# Examples

## Global Methods

### Global Moran's I coefficient

#### Implementation using `VOYAGER`


```{r, eval = TRUE}
sfe_tissue <-  colDataUnivariate(sfe_tissue, features = c("nCounts", "nGenes"), 
                                colGraphName = "visium", nsim = 1000,
                                type = "moran.mc")

res <- colFeatureData(sfe_tissue)[c("nCounts", "nGenes"),]
#value of the metric
res$moran.mc_statistic_Vis5A
#p-value
res$moran.mc_p.value_Vis5A

plotMoranMC(sfe_tissue, c("nCounts", "nGenes"))
```


The number of genes per spot shows a Moran's $I$ of $\sim 0.38$ which indicates auto-correlation. The number of counts per spot shows a Moran's $I$ of $\sim 0.53$. 

### Global Geary's C coefficient

#### Implementation using `VOYAGER`


```{r}
# taken from https://pachterlab.github.io/voyager/articles/visium_10x.html
sfe_tissue <-  colDataUnivariate(sfe_tissue, features = c("nCounts", "nGenes"), 
                                colGraphName = "visium", nsim = 1000,
                                type = "geary.mc")

res <- colFeatureData(sfe_tissue)[c("nCounts", "nGenes"),]
#value of the metric
res$geary.mc_statistic_Vis5A
#p-value
res$geary.mc_p.value_Vis5A
```


The Geary's $C$ statistic gives a value of $0.47$ for the number of counts and $0.61$ for the number of genes. The interpretation is that both features show positive auto correlation. 

### Global Getis-Ord $G$ statistic

--> weights should be binarised for this test - how to do this?


```{r}
weights_neighbourhoods <- colGraph(sfe_tissue, "visium")

spdep::globalG.test(x = sfe_tissue$nGenes, listw = weights_neighbourhoods)
spdep::globalG.test(x = sfe_tissue$nCounts, listw = weights_neighbourhoods)
```


## Local Measures for Univariate Data

### Local Moran's I coefficient

#### Implementation using `Voyager` 


```{r}
sfe_tissue <- colDataUnivariate(sfe_tissue, type = "localmoran", features = c("nCounts", "nGenes"))

plotLocalResult(sfe_tissue, "localmoran", features = c("nCounts", "nGenes"), ncol = 2,
                colGeometryName = "spotPoly", divergent = TRUE, 
                diverge_center = 0)
```


### Local Geary's C coefficient

#### Implementation using `Voyager` 


```{r}
sfe_tissue <- colDataUnivariate(sfe_tissue, "localC_perm", features = c("nCounts", "nGenes"))

plotLocalResult(sfe_tissue, "localC_perm", features = c("nCounts", "nGenes"), ncol = 2,
                colGeometryName = "spotPoly", divergent = TRUE, 
                diverge_center = 0)
```


### Local Getis-Ord $G_i$ coefficient

#### Implementation using `Voyager` 


```{r}
sfe_tissue <- colDataUnivariate(sfe_tissue, 
                                "localG",
                                features = c("nCounts", "nGenes"))

plotLocalResult(sfe_tissue, "localG", features = c("nCounts", "nGenes"), ncol = 2,
                colGeometryName = "spotPoly", divergent = TRUE, 
                diverge_center = 0)
```


### Local Spatial Heteroscedasticity (LOSH)

#### Implementation using `Voyager` 
                  

```{r}
#| eval: false
# run localG with permutation test
sfe_sub <- colDataUnivariate(sfe_tissue,
                     features = c("Mdk"),
                     type = "LOSH")


plotLocalResult(sfe_tissue, "LOSH",
                features = "Mdk",
                colGeometryName = "centroids")
```


# Appendix

## Session info


```{r}
#| label: session-info
sessionInfo()
```

