# Irregular Lattices

## Dependencies

```{r}
#| label: load-libs
#| message: false
#| warning: false
#| results: hide
source("utils.R")
theme_set(theme_minimal())
```

Until now, we have considered the cells to be represented in a point pattern. However, as cells have a shape and area, this might be an oversimplification in some cases. Alternatively, we can rely on the segmentation of individual cells that are available for various datasets. The outline of each cell is represented by a polygon and the collection of all cells can be seen as an irregular lattice. Unlike a regular lattice (e.g., spot-based spatial transcriptomics data), the sample areas in an irregular lattice can have different sizes and are not necessarily regularly distributed over the sample space.

For this representation of the cells we will rely on the `SpatialFeatureExperiment` package. For preprocessing of the dataset we refer the reader to the [vignette](https://pachterlab.github.io/voyager/articles/vig4_cosmx.html) of the `voyager` package [@mosesVoyagerExploratorySinglecell2023]. The `voyager` package also provides wrapper functions around the package `spdep` [@pebesmaSpatialDataScience2023] that work directly on the `SpatialFeatureExperiment` object.

```{r}
(sfe <- HeNSCLCData())

# Empty cells
colData(sfe)$is_empty <- colData(sfe)$nCounts < 1
# Select, sum negative control probes
(neg_inds <- str_detect(rownames(sfe), "^NegPrb")) %>% sum


colData(sfe)$prop_neg <- colSums(counts(sfe)[neg_inds,])/colData(sfe)$nCounts
# Remove low quality cells
sfe <- sfe[,!sfe$is_empty & sfe$prop_neg < 0.1]
# Re-calculate stats
rowData(sfe)$means <- rowMeans(counts(sfe))
rowData(sfe)$vars <- rowVars(counts(sfe))
rowData(sfe)$is_neg <- neg_inds
# log Counts
sfe <- logNormCounts(sfe)
```

<!-- Markers: KRT17 (basal cells), C1QA (macrophages), IL7R (T cells), TAGLN (Smooth muscle cells) -->

In this vignette, we will show the metrics related to two marker genes: KRT17 (basal cells) and TAGLN (smooth muscle cells).

```{r}
plotSpatialFeature(sfe, c("KRT17"),
                   colGeometryName = "centroids", 
                   ncol = 2, scattermore = TRUE) + 
  theme_void()

plotSpatialFeature(sfe, c("TAGLN"),
                   colGeometryName = "centroids", 
                   ncol = 2, scattermore = TRUE) + 
  theme_void()
```


{{< embed theory_irreg_lattice.qmd >}}

```{r}
colGraph(sfe, "knn5") <- findSpatialNeighbors(sfe, method = "knearneigh",
                                                  dist_type = "idw", k = 5, 
                                                  style = "W")
```


{{< embed univar_theory_lattice.qmd >}}


# Examples

## Global Methods

### Global Moran's I coefficient

#### Implementation using `voyager`

```{r}
calculateMoransI(sfe,
    features = c("KRT17", "TAGLN"),
    colGraphName = "knn5",
    exprs_values = "logcounts"
)
```

We can also use the `moran.mc` function to calculate the Moran's I coefficient. This function uses a Monte Carlo simulation to calculate the P-value. 

```{r}
sfe <- runUnivariate(sfe,
                     features = c("KRT17", "TAGLN"),
                     colGraphName = "knn5",
                     exprs_values = "logcounts",
                     type = "moran.mc",
                     nsim = 200)

res <- rowData(sfe)[c("KRT17", "TAGLN"),]
#value of the metric
res$moran.mc_statistic_sample01
#P-value
res$moran.mc_p.value_sample01
```

We can see both genes have a positive Moran's I coefficient and a highly significant P-value. The expected value is $\mathbb{E}(I) = -1/(n-1)$ which is for large $N$ close to 0. Positive and significant values indicate that areas with similar values are clustered. It is important to note that this could be both at the high or low end of the values of interest. Negative values indicate clustering of alternating values, i.e., gives a measure of spatial heterogeneity. Moreover, one should note that the result is dependent on the neighbourhood matrix. Different neighbourhood matrices will give different results. To compare Moran's I coefficients between different values, we need to use the same neighbourhood matrix.

### Global's Geary's C coefficient

#### Implementation using `voyager`

```{r}
sfe <- runUnivariate(sfe,
                     features = c("KRT17", "TAGLN"),
                     colGraphName = "knn5", nsim = 200,
                     type = "geary.mc")

res <- rowData(sfe)[c("KRT17", "TAGLN"),]
#value of the metric
res$geary.mc_statistic_sample01
#P-value
res$geary.mc_p.value_sample01
```

<!-- #### Implementation using `spdep` -->

<!-- ```{r} -->
<!-- #create nearest neighbours weights  -->
<!-- weights_neighbourhoods <- colGraph(sfe, "knn5") -->
<!-- spdep::geary.test(x = logcounts(sfe)["KRT17",], -->
<!--                   listw = weights_neighbourhoods, -->
<!--                   randomisation = TRUE) -->
<!-- spdep::geary.test(x = logcounts(sfe)["TAGLN",], -->
<!--                   listw = weights_neighbourhoods, -->
<!--                   randomisation = TRUE) -->
<!-- ``` -->

Again, the value of Geary's $C$ indicates that the genes are spatially auto-correlated.

### Global Getis-Ord $G$ statistic

#### Implementation using `spdep`

```{r}
# Get the weight matrix from sfe object
weights_neighbourhoods_binary <- colGraph(sfe)
# Change it to binary weights
weights_neighbourhoods_binary$style <- "B" 
# Calculate the global G statistic
spdep::globalG.test(x = counts(sfe)["KRT17",], 
                    listw = weights_neighbourhoods_binary)
```

<!-- ```{r} -->
<!-- sfe <- runUnivariate(sfe, -->
<!--                      features = c("KRT17", "TAGLN"), -->
<!--                      colGraphName = "knn5", -->
<!--                      type = "globalG.test") -->
<!-- ``` -->


# Local measures

### Local Moran's I coefficient

#### Implementation using `voyager`

```{r}
#| fig-width: 15
#| fig-height: 10
sfe <- runUnivariate(sfe,
                     features = c("KRT17", "TAGLN"),
                     type = "localmoran")

plotLocalResult(sfe, "localmoran",
                features = c("KRT17", "TAGLN"), ncol = 2,
                colGeometryName = "centroids")
```


### Local Geary's C coefficient

#### Implementation using `voyager`

```{r}
#| fig-width: 15
#| fig-height: 10
sfe <- runUnivariate(sfe,
                     features = c("KRT17", "TAGLN"),
                     type = "localC")

plotLocalResult(sfe, "localC",
                features = c("KRT17", "TAGLN"), ncol = 2,
                colGeometryName = "centroids")
```

### Local Getis-Ord statistic

#### Implementation using `voyager`

```{r}
#| fig-width: 15
#| fig-height: 10

sfe <- runUnivariate(sfe,
                     features = c("KRT17", "TAGLN"),
                     #include_self = TRUE, # this would specify G_i^*(d)
                     type = "localG")

plotLocalResult(sfe, "localG",
                features = c("KRT17", "TAGLN"), ncol = 2,
                colGeometryName = "centroids")
```

The results above gives an estimate of the local Getis-Ord statistic for each cell, but no siginificance value. This can be done by using a permutation approach. As this computationally very intensive we will show it on a subregion of the tissue.

```{r}
#| fig-width: 25
#| fig-height: 10

bbox_use <- st_as_sfc(st_bbox(c(xmin = 3200, xmax = 16800, ymin = 155200, ymax = 166200)))
sfe_sub <- sfe[,st_intersects(colGeometries(sfe)$centroids, bbox_use, sparse = FALSE)]

# run localG with permutation test
sfe_sub <- runUnivariate(sfe_sub,
                     features = "KRT17",
                     #include_self = TRUE, # this would specify G_i^*(d)
                     type = "localG_perm")

p1 <- plotLocalResult(sfe_sub, "localG_perm",
                features = "KRT17",
                colGeometryName = "centroids")

p2 <- plotLocalResult(sfe_sub, "localG_perm",
                features = "KRT17",
                attribute = "-log10p_adj Sim",
                colGeometryName = "centroids")

p1 | p2
```

Positive values indicate clustering of high values, i.e., hot spots, and negative values indicate clustering of low values, i.e., cold spots. The method does not detect outlier values because, unlike in local Moran's I, there is no cross-product between $i$ and $j$. But unlike local Moran's I, we know the type of interaction exists (high-high or low-low) between $i$ and $j$.

### Local spatial heterosceadiscity (LOSH)

#### Implementation using `spdep`

```{r}
#| fig-width: 15
#| fig-height: 10

# run localG with permutation test
sfe_sub <- runUnivariate(sfe_sub,
                     features = "KRT17",
                     type = "LOSH")


plotLocalResult(sfe_sub, "LOSH",
                features = "KRT17",
                colGeometryName = "centroids")

```

## A note of caution

The local methods presented above should always be interpreted with care, since we face the problem of multiple testing when calculating them for each cell. Moreover, the presented methods should mainly serve as exploratory measures to identify interesting regions in the data. Multiple processes can lead to the same pattern, thus from identifying the pattern we cannot infer the underlying process. Indication of clustering does not explain why this occurs. On the one hand, clustering can be the result of spatial interaction between the variables of interest. We have an accumulation of a gene of interest in one region of the tissue. On the other hand clustering can be the result spatial heterogeneity, when local similarity is created by structural heterogeneity in the tissue, e.g., that cells with uniform expression  of a gene of interest are grouped together which then creates the apparent clustering of the gene expression measurement. 

# Appendix

## Session info

```{r}
#| label: session-info
sessionInfo()
```
