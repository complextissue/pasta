# Discrete Marks

## Dependencies

```{r, cache=FALSE}
source("utils.R")
```

## Setup

```{r, cache=FALSE}
#| label: load-data
spe <- readRDS("../data/spe.rds")

#subset the data to only look at sample ID 0.01
sub <- spe[, spe$sample_id == 0.01]
(pp <- .ppp(sub, marks = "cluster_id"))

#split the multitype point process into several single type processes
#first, set the marks of the point process to be factors
marks(pp) <- factor(marks(pp))
ppls <- split(pp)
```

If not otherwise indicated, all information was taken from Baddeley et al. - Spatial Point Patterns.

```{r, fig.width=12, fig.height=12, cache=FALSE}
#Plot the entire point process where the marks are overlayed
plot(unmark(pp), main = 'Point Pattern Unmarked')
#Plot the marks separately 
plot(ppls, main = 'Point Pattern Marks Separated')
```

## Concepts and Definitions of Point Processes

### Point Process

```{r}

```

### Complete Spatial Randomness

Complete spatial randomness (CSR) is the null model of point patterns, being the result of a poisson process. A completely random process is characterised by two properties

#### Homogeneity

Homogeneity means that the expected number of points falling into a given region $B$ is proportional to its area $|B|$ given a proportionality constant $\lambda$. The constant $\lambda$ is the intensity of the process, so the average number of points in a unit area.

$$
\mathbb{E}[X\cap B] = \lambda |B|
\label{eq:expected_number_points}
$$

#### Independence

Independence means that in two regions $A$ and $B$ the number of points $n(X\cap A)$ and $n(X\cap B)$ are two independent random variables. That means the number of points in region $A$ does not affect the number of points in region $B$. The number of points follow a poisson distribution:

$$
\mathbb{P}[N=k] = e^{-\mu}\frac{\mu^k}{k!}\\
\label{eq:poisson_process}
$$

### Inhomogeneous Poisson Process

A poisson process that is spatially varying in its average density of points is called inhomogeneous. Here, the average density $\lambda(u)$ is a function of spatial location $u$. The expected number of points falling into a region $B$ is

$$
\mu = \int_{B} \lambda(u)du 
\label{eq:expected_number_inhomogeneous}
$$

### Isotropy

A point process is called isotropic, if its statistical properties are invariant to rotations. A CSR process is both stationary and isotropic.

### Stationarity

"A point process is called stationary if, when we view the process through a window $W$, its statistical properties do not depend on the location of the window in two-dimensional space."

#### Correlation stationarity

It is important to note that the inhomogeneous metrics do not apply to every spatially inhomogeneous point process. They only apply to point processes which are correlation stationary. A point pattern is correlation stationary if the metric only depends on the relative position in subpatterns of the point process, which means that estimates of the inhomogeneous metric should be similar in different subquadrats of the point pattern.

### Local scaling

The inhomogeneous K-function further assumes that while the intensity is spatially varying, the scale of the interaction remains constant. This is equivalent to the assumption that in small subregions the process is stationary and isotropic, but the rescaling factor can vary across the total process. In this case the locally scaled version of the K-function is applicable.

We can use a permutation test to test the inhomogeneity assumption. In this scenario, we split the patterns into quadrats and compare the estimatied functions between the quadrats. It has to be noted that this test highly depends on the arbitrarydefinition of the quadrats.

```{r}
selection <- c('OD Mature')
pp_sel <-  subset(pp, marks %in% selection, drop = TRUE)


odrho <- rhohat(unmark(pp_sel), "x", method="tr")
odlambda <- predict(odrho)

od4 <- quantess(unmark(pp_sel), "x", 2)
od42 <- nestsplit(pp_sel, od4, ny=3)

plot(od42)

od42$inten <- factor(as.integer(od42$f1) <= 1, labels=c("Hi","Lo"))

res.scaled <- studpermu.test(od42, pts ~ inten, summaryfunction=Kscaled,
               minpoints = 10)

res.inhom <- studpermu.test(od42, pts~ inten, summaryfunction=Kinhom,
               lambda=odlambda, minpoints = 10)

#p-value of the local-scaling test
res.scaled$p.value

#p-value of the inhomogeneity test
res.inhom$p.value
```

Alternatively, we can inspect deviations against the hypothesis that the points were generated by a Poisson process. We can identify hotspots and coldspots by comparing the standard error of the `relrisk` function, which computes nonparamatric estimates of the relative risk by kernel smoothing, to the theoretical null distribution of points. The relative risk is the ratio of spatially varying probablilities of different types. [Source](https://idblr.rbind.io/post/pvalues-spatial-segregation/)

#TODO: We should maybe move this to after the intensity part

```{r}
# select marks
selection <- c('OD Mature', 'Ependymal', 'Microglia')
pp_sel <-  subset(pp, marks %in% selection, drop = TRUE)

f1 <- pValuesHotspotMarks(pp_sel)

# Plot significant p-values
plot(f1$p, main = "Significant difference\n to Poisson process alpha = 0.05")
```

```{r}
f0 <- pValuesHotspot(pp_sel)

# Plot significant p-values
plot(f0$p, main = "Significant difference\n to Poisson process alpha = 0.05")
```

````{=html}
<!-- 
```{r}
selection <- c('Ependymal')
pp_sel <-  subset(pp, marks %in% selection, drop = TRUE)


odrho <- rhohat(unmark(pp_sel), "x", method="tr")
odlambda <- predict(odrho)

od4 <- quantess(unmark(pp_sel), "x", 2)
od42 <- nestsplit(pp_sel, od4, ny=3)

plot(od42)

od42$inten <- factor(as.integer(od42$f1) <= 1, labels=c("Hi","Lo"))

studpermu.test(od42, pts ~ inten, summaryfunction=Kscaled, minpoints = 10)

studpermu.test(od42, pts~ inten, summaryfunction=Kinhom,
               lambda=odlambda, minpoints = 10)
``` 
-->
````

### Intensity

Intensity is the expected density of points per unit area, as seen above. It can be interpreted as the rate of occurrence or the abundance of events recorded. The intensity itself is called a first moment property - being related to the expected number of points.

#### Estimating Intensity

The intensity can be estimated regardless of the type of the point pattern. In order to do so, we sum the individual intensities of the marks

```{r, cache=FALSE}
intensityPointProcess<- function(pp,mark){
  if(mark == TRUE){
    return(intensity(pp))
  }
  else{
    return(sum(intensity(pp)))
  }
}

intensityPointProcess(pp,mark=FALSE)
```

else we can look at each mark individually

```{r, cache=FALSE}
intensityPointProcess(pp,mark=TRUE)
```

#### Quadrat Counting

In quadrat counting all the points falling into a given quadrat are counted. This gives an overview on the characterstics of the point pattern, such as correlation stationarity.

```{r, fig.width=12, fig.height=12, cache=FALSE}
Q5 <- quadratcount(pp, nx=5, ny=5)
plot(unmark(pp), main='Unmarked Point Pattern Quadrats')
plot(Q5, col='black', add=TRUE)
```

````{=html}
<!-- or for each type separately, treating each type as an unmarked process

```{r, fig.width=12, fig.height=12, cache=FALSE}
Q5sep <- quadratcount(ppls, nx=5, ny=5)
plot(Q5sep, main = 'Separated Marks Quadrats')
#plot(ppls, add=TRUE)
``` 
-->
````

The quadrat counts can be tested against regularity. This can happen again in the unmarked pattern or in the separated types. This tells us if the counts of the points are distributed evenly across the quadrats.

```{r, cache=FALSE}
quadratTestPointProcess <- function(pp, mark){
  if(mark==TRUE){
    return(lapply(split(pp), quadrat.test, 5, alternative="regular", method="MonteCarlo"))
  }
  else{
    return(quadrat.test(unmark(pp), 5, alternative="regular", method="MonteCarlo"))
  }
}
quadratTestPointProcess(pp, mark=FALSE)
```

#### Kernel Estimation

In kernel estimation we try to estimate the intensity function $\lambda(u)$ of the point process. There are different types of kernel estimators (see Baddeley). A popular choice is the isotropic Gaussian kernel where the standard deviation corresponds to the smoothing bandwidth.

```{r, fig.width=8, fig.height=8}
Dens <- density(pp)
plot(Dens, main = 'Kernel Density')
```

````{=html}
<!-- 

```{r, fig.width=12, fig.height=12, cache=FALSE}
Denssep <- density(ppls)
plot(Denssep, main = 'Kernel Density Separated Marks  ')
``` 


### Summarising Functionality for Estimating Intensity - unfinished

```{r, eval=FALSE, cache=FALSE}
#PRE:
#POST:
estimatingIntensity <- function(
  pp
  method = c('expectation', 'quadrat', 'kernel', 'density', 'adaptive-density'),
  homogeneous = FALSE,
  nx = NULL,
  ny = NULL,
  correction = c(),
){

}
```
-->
````

### Testing for CSR

Whether or not a point process is completely spatially random depends on two characeteristics. The points have to be distributed homogeneously and they have to be independent of each other (see definitions above). There are different ways to test for CSR which are summarised in the wrapper below.

```{r, cache=FALSE}
#PRE: takes a point process and the indication, which test for CSR should be performed and potentially a covariate
#POST: returns if a point process or its individual point process marks are CSR or not.
#TODO: Change maybe to a switch statment in terms of computing time; Change lapply to mclapply later on
#TODO: There is a conceptual mistake - we pull out marks and test them against a markov simulation. It should rather be to test against all the other cells
testingCSR <- function(
    pp,
    method = c('quadrat','cdf','bermans','clark-evans','hopkins-skellam'),
    mark = FALSE,
    covariate = NULL,
    test = c('ks', 'cvm', 'ad'),
    verbose = FALSE
){
  #perform a quadrattest for individual marks or for the entire pointprocess
  if(method == 'quadrat'){
    if(mark == TRUE){
      test.result <- lapply(split(pp), quadrat.test, 5, method="MonteCarlo")
    }
    else{
      test.result <- quadrat.test(unmark(pp), 5, method="MonteCarlo")
    }
   }
  #perform a cdftest for individual marks or for the entire pointprocess given a covariate
  else if(method == 'cdf' && !is.null(covariate)){
    if(mark == TRUE){
      test.result <- lapply(split(pp), cdf.test, covariate, test=test)
    }
    else{
      test.result <- cdf.test(unmark(pp), covariate, test=test)
    }
  }
  #perform a bermans test for individual marks or for the entire pointprocess
  else if(method == 'bermans' && !is.null(covariate)){
     if(mark == TRUE){
      test.result <- lapply(split(pp), berman.test, covariate, test='Z1')
    }
    else{
      test.result <- berman.test(unmark(pp), covariate, test='Z1')
    } 
  }
  #perform a clark evans test for individual marks or for the entire pointprocess
  else if(method == 'clark-evans'){
     if(mark == TRUE){
      test.result <- lapply(split(pp), clarkevans.test)
    }
    else{
      test.result <- clarkevans.test(unmark(pp))
    } 
  }
  #perform a hopkins-skellam test for individual marks or for the entire pointprocess
  else if(method == 'hopkins-skellam'){
     if(mark == TRUE){
      test.result <- lapply(split(pp), hopskel.test)
    }
    else{
      test.result <- hopskel.test(unmark(pp))
    } 
  }
  #base case of the "switch" statement
  else{
    print("ERROR: non-specified arguments or methods")
    return(NULL)
  }
  
  #summarise the results as a mask of booleans to indicate which structures are 
  #random and which are not
  if(mark==TRUE){
    p.value.mask <- lapply(test.result, function(x) x$p.value>0.05)
  }
  else{
    p.value.mask <- test.result$p.value>0.05
  }
  #return the values of the test calculations, either just the boolean if 
  #CSR or not or the entire test statistics
  if(verbose == TRUE){
    return(test.result)
  }
  else{
    return(p.value.mask)
  }
}
result <- testingCSR(pp,method='clark-evans',mark=TRUE, verbose=FALSE)

testingCSR(ppls$Ependymal, method='clark-evans')
testingCSR(ppls$`OD Mature`, method='clark-evans')
testingCSR(ppls$Microglia, method='clark-evans')
```

## Correlation

Correlation or more generally covariance is called a second order quantity and measures dependence between data points. This is a very useful concept, allowing for the assessment of correlation between points.

````{=html}
<!-- 
### Morisita Index

$$
M = m \frac{\sum_jn_j(n_j-1)}{n(n-1)}
$$

where we subdivide the point process into $m$ quadrats. The formula above is called the Morisita index which is the ratio of observed and expected fractions. If the points are independent the Morisita index is close to 1, greater than 1 if they are clustered, and less than 1 if they are regular. This concept is closely linked to the index of dispersion (in fact with a bit of algebra, these two can be transformed into each other)

$$
I = \frac{s^2}{\bar{n}} = \frac{m}{n(m-1)}\sum_{j=1}^m\left(n_j-\frac{n}{m}\right)^2
$$

```{r, cache=FALSE}
miplot(ppls$Ependymal)
miplot(ppls$`OD Mature`)
miplot(ppls$Microglia)
```

### Fry plot

A fryplot is a scatterplot of the vector differences $x_j-x_i$ between all paris of distinct points in the pattern.

```{r, cache=FALSE}
fryplot(ppls$Ependymal)
fryplot(ppls$`OD Mature`)
fryplot(ppls$Microglia)
``` 
-->
````

### Ripley's $K$

#### Empirical Ripley's $K$

In the framework of correlation analysis we often look at distances $d_{ij} = ||x_i-x_j||$ of all ordered points. It is a natural idea to look at the summary of these distances $d_{ij}$, e.g. a histogram. The histogram of this point process is a difficult statistic, as it depends on the observation window $W$, thus the histogram can change significantly with a changing window $W$. Therefore, we look at the empirical distribution function of the distances $d_{ij}$ that are smaller or equal than a radius $r$

$$
\hat{H}(r) = \frac{1}{n(n-1)}\sum_{i=1}^n \sum_{j=1\\j\neq i}^n \{d_{ij}\leq r\}
$$

The contribution of each point $x_i$ to the sum above is

$$
t_i(r) = \sum_{j \neq i} \mathbb{1} \{d_{ij}\leq r\}
$$

this number $t_i(r)$ is the number of points that fall within a radius $r$ centered at $x_i$. It follows then:

$$
\hat{H}(r) = \frac{1}{n(n-1)}\sum_{i=1}^n t_i(r) = \frac{1}{n-1} \bar{t}(r)
$$

Here, we see what we actually want to measure is "the average number of r-neighbours of a typical random point". This number is still dependent on the size of the observation window so we want to standardise is by the number of points and $|W|$ the window size. Then we obtain the empirical Ripley's $K$ function

$$
\hat{K}(r) = \frac{|W|}{n(n-1)}\sum_{i=1}^n\sum_{j=1 \\j \neq i}^n\{d_{ij}\leq r\}
$$

The standardisation makes it possible to compare point patterns with different observation windows and with different numbers of points. Using the empirical $K$ function assumes though tha the point process has homogeneous intensity.

#### True $K$-function

instead of the summary of pairwise distances, we are interested in the point process. In order to do so, we have to think about the expected number of $r$-neighbours given a point $X$ at a location $u$ divided by its intensity $\lambda$

This means

$$
K(r) = \frac{1}{\lambda} \mathbb{E} [t(u,r,X)|u \in X]
$$

where

$$
t(u,r,X) = \sum_{j=1}^{n(X)} \mathbb{1} \{0<||u-x_j||\leq r\}
$$

This definition of the true $K$ function is only valid if the point process is stationary. For a homogeneous poisson process we obtain

$$
K_{pois}(r) = \pi r^2
$$

#### Edge effects and their corrections for spatial metrics

Edge effects describe the phenomenon that we never observe the entire point process but only a part of it within a window $W$. This means that parts of the point process at the border might not be observed and the value of the statistic biased along the edges.

There are many corrections for edge effects. They are briefly listed here

##### Border correction

In border correction the summation of data points is restricted to $x_i$ for which $b(x_i,r)$ is completely in the window $W$.

##### Isotropic correction

We can regard edge effect as a sampling bias. Larger distances (e.g. close to the edges) are less likely to be observed. This can be corrected for.

##### Translation correction

A stationary point process $X$ is invariant to translations. So the entire point process can be shifted by a vector $s$ to be at the position $X+s$.

### The $L$-function

The $K$-function can be centered which is then called the $L$-function. The $L$-function is a variance-stabilising version of the $K$-function (see spicyR for reference).

$$
L(r) = \sqrt{\frac{K(r)}{\pi}}
$$

### Pair Correlation function

We have seen above, that the $K$-function is cumulative in nature. Meaning that the contributions of all distances smaller equal to $r$ are counted. An alternative is to take the derivative of the $K$-function in order to obtain contributions of distances between points equal to $r$.

$$
g(r) = \frac{K'(r)}{2\pi r}
$$

"$g(r)$ is the probability of observing a pair of point of the process separated by a distance $r$, divided by the corresponding probability for a Poisson process."

#### Estimator of the pair correlation function

The pair correlation function can be estimated via kernel smoothing. In very large datasets the pair correlation function can be approximated using histogram-based methods.

$$
\hat{g}(r) = \frac{|W|}{2 \pi r n (n-1)} \sum_{i=1}^n\sum_{j=1 \\j \neq i}^n \kappa_h(r-d_{ij})e_{ij}(r)
$$

where $\kappa$ is the smoothing kernel. $\kappa_h(x)$ is a rescaled version of the template kernel $\kappa$

$$
\kappa_h(x) = \frac{1}{h}\kappa\left(\frac{x}{h}\right)
$$

In the above, $\kappa$ can be any probability density "over the real line with mean 0". Usually, the Epanechinikov kernel is used as smoothing kernel with half-width $w$.

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide'}
#| message: false
#| warning: false
#PRE: list of point pattern, corresponding celltypes of interest, functions to evaluate
#POST: result of the metric
metricResBoot <- function(ppls, celltype, fun){
  metric.res <- lohboot(ppls[[celltype]], fun = fun)
  metric.res$type <- celltype
  return(metric.res)
}
#PRE: celltypes, function to calculation and edge correction method
#POST: dataframe of 
metricResBootToDF <- function(celltype_ls, ppls, fun, edgecorr){
  res_ls <- lapply(celltype_ls, metricResBoot, fun = fun, ppls = ppls)
  #stick all values into a dataframe
  res_df <- c()
  for(i in 1:length(celltype_ls))res_df <- rbind(res_df, res_ls[[i]])
  return(res_df)
}

#PRE: Celltypes of interest, function to analyse, edge correction to perform
#POST: plot of the metric
plotMetric <- function(celltype_ls, ppls, fun, edgecorr){
  res_df <- metricResBootToDF(celltype_ls, ppls, fun, edgecorr)
  #plot the curve
  p <- ggplot(res_df, aes(x=r, y=res_df[[edgecorr]], col= type))+
    geom_line()+
    geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.25)+
    ggtitle(paste0(fun, '-function'))+
    geom_line(aes(x=r,y=theo, color = 'Poisson'),linetype = "dashed")+
    ylab(edgecorr) +
    scale_color_manual(name='Point Processes',
                     breaks=c('Ependymal', 'Microglia', 'OD Mature', 'Poisson'),
                     values=c('Ependymal'='red', 'Microglia'='dark green', 'OD Mature'='blue', 'Poisson'='black'))+
    theme_light()
  return(p)
}

celltype_ls <- c("Ependymal", "OD Mature", "Microglia")
p_K <- plotMetric(celltype_ls, ppls, 'Kest', 'iso')

p_L <- plotMetric(celltype_ls, ppls, 'Lest', 'iso')

p_g <- plotMetric(celltype_ls, ppls, 'pcf', 'border')
```

```{r, cache=FALSE, fig.height = 10, fig.width = 7}
p_K/p_L/p_g
```

### Correcting for Inhomogeneity

#### Inhomogeneous $K$-function

In the case that a spatial pattern is known or suspected to be inhomogeneous, we have to take this into account for our analysis. Biological samples display inhomogeneity very often, therefore this analysis is preferred over the homogeneous alternatives. Inhomogeneous alternatives can be calculated via:

$$
K_{inhom}(r) = \mathbb{E} \left[\sum_{x_j \in X} \frac{1}{\lambda(x_j)}\mathbb{1}\{0<||u-x_j||\leq r\}|u \in X\right]
$$

This theoretical quantity can be approximated with estimators such as

$$
\hat{K}_{inhom}(r) = \frac{1}{D^p|W|}\sum_i\sum_{j \neq i} \frac{\mathbb{1}\{||u-x_j||\leq r\}}{\hat{\lambda}(x_j)\hat{\lambda}(x_i)}e(x_j,x_i;r)
$$

where $e(u,v;r)$ is an edge correction weight, $\hat{\lambda}(u)$ is an estimator of the intensity of $u$ and $D^p$ is the pth power of

$$
D = \frac{1}{|W|}\sum_i \frac{1}{\hat{\lambda}(x_i)}
$$

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide'}
p_K <- plotMetric(celltype_ls, ppls, 'Kinhom', 'iso')

p_L <- plotMetric(celltype_ls, ppls, 'Linhom', 'iso')

p_g <- plotMetric(celltype_ls, ppls, 'pcfinhom', 'border')
```

```{r, cache=FALSE, fig.height = 10, fig.width = 7}
p_K/p_L/p_g
```

The inhomogeneous $K$-function tells us that the microglia cells follow a Poisson process (dashed line) closely and can therefore be assumed to be randomly distributed and not clustered. Ependymal cells show a high degree of clustering at a low radius $r$. OD mature cells are in the middle, showing a lower degree of clustering at lower values of $r$.

The $L$-function is a variance stabilised (source spicyR) version of the $K$-function. Thus, the information is complementary to the above. Microglia cells are along the dashed poisson line, indicating no clustering of microglia cells. Ependymal cells are highly clustered at low values of $r$, whereas OD mature show intermediate clustering at lower values of $r$.

The pair correlation function is the derivative of the $K$-function. Therefore, it is not a sum of the points in the circle with radius $r$ but rather the individual points on the radius $r + h$ where $h$ is very small. The pcf plot gives similar information as before: Microglia cells are around the dashed poisson line. OD Mature cells show a rather broad range of correlations between $r \in [20,100]$. Ependymal cells have a very strong correlation at $\sim r = 25$.

We have to note that inhomogeneity correction assumes that the process is correlation stationary, meaning that the summary statistics are the same in each quadrat. This is clearly violated at least for Ependymal cells and OD mature cells. Therefore, the question remains whether acounting for one issue (homogeneity) via a correction that assumes correlation stationarity does not just exchange one problem for another.

### Local Scaling

#### Locally-scaled $K$-function

In the inhomogeneous $K$ approach above, we assume that the local scale of the point process is not changed. However, the intensity can vary spatially. In a biological sample, this assumption is easily violated,  e.g. when a gradient of cells that increases from one side to another. Therefore, we can assume that the process is subdivided in small regions. In these small regions the point process is a scaled version of a template process. This template process has to be both stationary and isotropic. For two locations $u$ and $v$ we would then assume that

$$
g(u,v) = g_1 \left(\frac{||u-v||}{s}\right)
$$

In this example, $g_1$ is the pair correlation function of the template process and $s$ a scaling factor.

#### Locally-scaled pair-correlation function

would work by taking the derivative of the locally scaled $K$-function

#### Locally-scaled $L$-function

As the $L$ is just a transformation of the $K$-function, the same local scaling can apply to the $L$-function

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide'}
### need to redefine the metric function, because bootstrap is not available for locally scaled functions ###
#PRE: list of point pattern, corresponding celltypes of interest, functions to evaluate
#POST: result of the metric
metricRes <- function(ppls, celltype, fun){
  metric.res <- do.call(fun, args = list(X=ppls[[celltype]]))
  metric.res$type <- celltype
  return(metric.res)
}

#PRE: celltypes, function to calculation and edge correction method
#POST: dataframe of 
metricResToDF <- function(celltype_ls, ppls, fun, edgecorr){
  res_ls <- lapply(celltype_ls, metricRes, fun = fun, ppls = ppls)
  #stick all values into a dataframe
  res_df <- c()
  for(i in 1:length(celltype_ls))res_df <- rbind(res_df, res_ls[[i]])
  return(res_df)
}
### need to redefine the plotting function, because bootstrap is not available for locally scaled functions ###
#PRE: Celltypes of interest, function to analyse, edge correction to perform
#POST: plot of the metric
plotScaledMetric <- function(celltype_ls, ppls, fun, edgecorr){
  res_df <- metricResToDF(celltype_ls, ppls, fun, edgecorr)
  #plot the curve
  p <- ggplot(res_df, aes(x=r, y=res_df[[edgecorr]], col= type))+
    geom_line(linewidth=1)+
    ggtitle(paste0(fun, '-function'))+
    geom_line(aes(x=r,y=theo, color = 'Poisson'),linetype = "dashed", linewidth=1)+
    ylab(edgecorr) +
    scale_color_manual(name='Point Processes',
                     breaks=c('Ependymal', 'Microglia', 'OD Mature', 'Poisson'),
                     values=c('Ependymal'='red', 'Microglia'='dark green', 'OD Mature'='blue', 'Poisson'='black'))+
    theme_light()
  return(list(p = p, res_df = res_df))
}

p_K <- plotScaledMetric(celltype_ls, ppls, 'Kscaled', 'iso')$p
p_L <- plotScaledMetric(celltype_ls, ppls, 'Lscaled', 'iso')$p
```

```{r, cache=FALSE, fig.height = 10, fig.width = 7}
p_K/p_L
```

```{r, eval=FALSE, include=FALSE}
plotScaledMetric <- function(celltype_ls, ppls, fun, edgecorr){
  res_df <- metricResToDF(celltype_ls, ppls, fun, edgecorr)
  #plot the curve
  p <- ggplot(res_df, aes(x=r, y=res_df[[edgecorr]], col= type))+
    geom_line(linewidth=1)+
    ggtitle(paste0(fun, '-function'))+
    geom_line(aes(x=r,y=theo, color = 'Poisson'),linetype = "dashed", linewidth=1)+
    ylab(edgecorr) +
    # scale_color_manual(name='Point Processes',
    #                  breaks=c('Ependymal', 'Microglia', 'OD Mature', 'Poisson'),
    #                  values=c('Ependymal'='red', 'Microglia'='dark green', 'OD Mature'='blue', 'Poisson'='black'))+
    theme_light()
  return(list(p = p, res_df = res_df))
}

functional.pca.pp <- function(res_df){
  df <- res_df
  fd_obj <- fdapace::MakeFPCAInputs(IDs = res_df$type, tVec=res_df$r, yVec=res_df$border)
  #check that the FPCA object is valid
  fdapace::CheckData(fd_obj$Ly, fd_obj$Lt)
  #run the computation of the FPCA - would work with sparse data.
  fpca_obj <- fdapace::FPCA(fd_obj$Ly, fd_obj$Lt, list(plot = TRUE, kernel='rect'))
  #fdapace::CreatePathPlot(fpca_obj,K = 3, pch = 4,showObs = FALSE, showMean = TRUE)
  return(fpca_obj)
}
celltype_ls_new <- c("Ependymal", "OD Mature", "Microglia", "Ambiguous", "Astrocyte", "Endothelial", "Excitatory", "Inhibitory", "OD Immature", "Pericytes")
print(plotScaledMetric(celltype_ls_new, ppls, 'Lscaled', 'iso')$p)
res_df <- plotScaledMetric(celltype_ls_new, ppls, 'Lscaled', 'iso')$res_df

fpca_obj <- functional.pca.pp(res_df) 

fpca_pc_df <- as.data.frame(fpca_obj$xiEst) %>% rename(PC1 = V1, PC2 = V2)
fpca_pc_df$type <- celltype_ls_new
# assume they are in same order

ggplot(fpca_pc_df, aes(x=PC1, y=PC2, col = type, label = type)) +
  geom_text(hjust=0, vjust=0) +
  geom_point() +
  theme_light() +
  ggtitle("Biplot of the L curves of all Celltypes")
```

The interpretation of the locally scaled $L$-function is similar to the interpreation of the inhomogeneous $L$-function. The correlation is strongest for Ependymal cells, followed by OD mature cells. Microglia cells are again close to the random poisson process. Note that here, the curves of the Ependymal and OD mature cells stay always above the dashed poisson line, unlike in the inhomogeneous version.

Given that our biological samples are both inhomogeneous and locally scaled by eye (can be tested as seen above), the locally scaled $L$-function seems a good variant for assessing correlation.

#### Local Indicators of Spatial Association

The $K$ and $L$-functions above are summary statistics over the entire pattern. However, if we know that there are different regions in our point pattern, we might want to know the individual contributions of these patterns. This gives then e.g. $n$ (for all points) local $K$,$L$ or pair correlation-functions. Baddeley et. al. propose to compare these $n$ functions with e.g. functional principal component analysis. We will show here the example of the LISA version of the $L$ function.

````{=html}
<!-- ##### Local $K$ function

```{r}
K_ependymal_lisa <- localK(ppls$Ependymal)
plot(K_ependymal_lisa, main = 'local K functions Ependymal', legend=FALSE)

K_odmature_lisa <- localK(ppls$`OD Mature`)
plot(K_odmature_lisa, main = 'local K functions OD Mature', legend=FALSE)

K_microglia_lisa <- localK(ppls$Microglia)
plot(K_microglia_lisa, main = 'local K functions Microglia', legend=FALSE)
```

##### Local pair correlation function

```{r}
g_ependymal_lisa <- localpcf(ppls$Ependymal)
plot(g_ependymal_lisa, main = 'local pcf functions Ependymal', legend=FALSE)

g_odmature_lisa <- localpcf(ppls$`OD Mature`)
plot(g_odmature_lisa, main = 'local pcf functions OD Mature', legend=FALSE)

g_microglia_lisa <- localpcf(ppls$Microglia)
plot(g_microglia_lisa, main = 'local pcf functions Microglia', legend=FALSE)
``` 
-->
````

##### Local $L$ function

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide'}
L_odmature_lisa <- localL(ppls$`OD Mature`)
# plot(L_odmature_lisa, main = 'local L functions OD Mature', legend=FALSE)

df <- as.data.frame(L_odmature_lisa)

dfm <- reshape2::melt(df, "r")

get_sel <- dfm %>% filter(r > 200.1358 & r < 200.1360, variable != "theo") %>%
  mutate(sel = value) %>% select(variable, sel)

dfm <- dfm %>% left_join(get_sel)

p <- ggplot(dfm, aes(x=r, y=value, group=variable, colour=sel)) +
  geom_line() + 
  scale_color_continuous(type = "viridis") +
  geom_vline(xintercept = 200) +
  theme(legend.position = "none") +
  theme_light()

ppdf <- as.data.frame(pp) %>% filter(marks=="OD Mature")
ppdf$sel <- get_sel$sel # assume they are in same order

q <- ggplot(ppdf, aes(x=x, y=y, colour=sel)) + 
  geom_point() +
  scale_color_continuous(type = "viridis") +
  theme(legend.position = "none") +
  theme_light()
```


```{r, fig.height=7, fig.width=10}
p|q
```

In the case of the OD mature cells we obtain further information with this plot. We note that there are two distinct populations of curves, those that are clearly above the straight poisson line and others that are around/underneath the straight poisson line. This indicates that there are two different kinds of interactions in the OD mature cells. Stronger clustering (the upper part of the plot) and more random parts (lower part).

There are inhomogeneous versions of these (e.g. `localLinhom`). These are not shown here for brevity.

##### Functional PCA for the $n$ Curves

We apply functional PCA to retrieve the main trends in these individual curves. The idea of functional PCA is the same as for ordinary PCA just applied to the concept of functions. For the $n$ functions above functional PCA will recover the main trends in the data

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide'}
#adapted from the fdapace vignette
functional.pca.pp <- function(df){
  #df <- res_df_wider
  df_fdob <- df %>% as.matrix()
  #remove theo column - we want only the actual estimations in there without the poisson line theo
  if('r' %in% colnames(df) || 'theo' %in% colnames(df)){
     df_fdob <- df_fdob[,!colnames(df_fdob) %in% c("r", "theo")]
  }
  if('Ependymal' %in% colnames(df)){
    df_fdob <- df_fdob[,!colnames(df_fdob) %in% c("trans",'iso')]
  }
  #number of columns
  N <- ncol(df_fdob)
  #number of rows
  M <- nrow(df_fdob)
  #the x values at which all the curves were evaluated, here called tVec
  s <- df$r
  #create the FPCA object
  fd_obj <- fdapace::MakeFPCAInputs(IDs = rep(1:N, each=M),tVec=rep(s,N), yVec=df_fdob)
  print(which( unlist( lapply(fd_obj$Lt, function(x) length(x) != length(unique(x))))))
  #check that the FPCA object is valid
  fdapace::CheckData(fd_obj$Ly, fd_obj$Lt)
  #run the computation of the FPCA - would work with sparse data.
  fpca_obj <- fdapace::FPCA(fd_obj$Ly, fd_obj$Lt, list(plot = TRUE, dataType='Dense', kernel='rect'))
  fdapace::CreatePathPlot(fpca_obj,K = 3, pch = 4,showObs = FALSE, showMean = TRUE)
  return(fpca_obj)
}

fpca_obj <- functional.pca.pp(L_odmature_lisa)
fpca_pc_df <- as.data.frame(fpca_obj$xiEst) %>% rename(PC1 = V1, PC2 = V2, PC3 = V3)
fpca_pc_df$sel <- get_sel$sel # assume they are in same order

ggplot(fpca_pc_df, aes(x=PC1, y=PC2, col = sel)) + 
  scale_color_continuous(type = "viridis") +
  geom_point() +
  theme_light() +
  ggtitle("Biplot of the LISA L curves of the OD mature cells")
```

Here, we see the functional PCA for the OD mature cells. The Design plot tells us that we have a very dense dataset over the entire support. The mean curve displays the mean trend over all $n$ LISA $L$-curves (note that this result is similar to the locally scaled $L$-function). The scree plot indicates that the first eigenfunction explains more than $80 \%$ of the variance. The eigenfunction curves in the bottom right panel indicate the deviation from the mean curve.

Looking at the second plot we see the smoothed mean curve and the individual curves that are reconstructed from the first three eigenfunctions. The first eigenfunction from the bottom right panel, $\phi_1$, is above the mean curve. When we look at the example that is clearly visible. $\phi_2$ is first above the mean curve and then lower than the mean curve. These curves are visible as well. Lastly, $\phi_3$ is curves that start low and pick up to be larger than the mean curve in the end. This is visible in e.g. the orange dashed line -\> check the source from the Springer book "Functional Data Analysis with R and Matlab".

The last plot shows the biplot of the functional PCA. Each point is a cell from the OD mature cells. The first two principal components are plotted. The first principal component is the x-axis and the second principal component is the y-axis. The points are coloured as in the plots of the LISA $L$-curves. We note that the first principal component separates the two populations. The curves with the high values (yellow) are plotted on the right and the ones with low values (blue) on the left. This corresponds to the two populations we saw in the LISA $L$-curve plot. 

### Third-Order Summary Statistics

So far we have considered first- and second-order summary statistics and local adaptations of these. In the following, we will continue a high-order statistics. In second-order statistics one considers pairs and counts these in the case of the $K$ function. In a third-order setting we would now count triplets of points. A triplet is counted as the normalised expected value of triangles where all edges are smaller than the radius r

$$
T(r) = \frac{1}{\lambda^3}\mathbb{E}\left[\sum_{i=1}^n\sum_{j=1\\j\neq i}^nm(x_i,x_j,u) | u \in X\right]
$$

here m is the maximum side of the triangle

$$
m(a,b,c) = \max(||a-b||,||a-c||,||b-c||)
$$

```{r}
p <- plotScaledMetric(celltype_ls, ppls, 'Tstat', 'trans')
p
```

## Spacing

So far, most approaches considered intensity and correlation as measures to assess a point pattern. Below, we will look at measures of spacing and shortest-distances to assess spatial arrangements.

Baddeley et.al. summarises three basic distances to measure

-   pairwise distance: $d_{i,j} = ||x_i-x_j||$
-   nearest-neighbour distances: $d_i = \min_{j \neq i}d_{ij}$
-   empty-space distance: $d(u) = \min_j||u-x_j||$

There are test of CSR that are based on spacing -\> Clark-Evans test and Hopkins-Skellam Index that are both implemented above in the CSR testing function

````{=html}
<!-- ### Exploratory Graphics

#### Stienen Diagram

The stienen diagram is obtained by drawing circles around each point in the process of the size of its nearest neighbour distance

```{r}
stienen(ppls$Ependymal)
stienen(ppls$`OD Mature`)
stienen(ppls$Microglia)
```

#### Dirichlet Tiles

Dirichlet tiles are considered as the space "that is closer to $x_i$ than to any other point in the pattern $x$:"

$$
C(x_i|x) = \{u \in \mathbb{R}^2:||u-x_i|| = \min_{j} ||u-x_j||\}
$$

These dirichlet tiles are convex polygons

```{r}
plot(dirichlet(ppls$Ependymal))
plot(dirichlet(ppls$`OD Mature`))
plot(dirichlet(ppls$Microglia))
``` 
-->
````

### Nearest Neighbour approaches

Nearest neighbour methods center around the notion of "nearness". In particular, we introduce `nndist` from `spatstat`, a method to calculate the distances until $k$ nearest neighbours are found. This function returns us then $k$ curves for the $k$ neighbour distances. We can for instance collapse this information of the $k$ curves in a mean curve per sample. This information of the mean nearest neighbour distance is summarised as a density.

```{r, cache=FALSE}
nndistance <- function(pp, nk){
  xy <- cbind(pp$x, pp$y)
  nndistances_k15 <- nndist(xy, k = nk) 
  nndistances_mean <- rowMeans(nndistances_k15)
  return(nndistances_mean)
}

#PRE: list of point pattern, corresponding celltypes of interest, functions to evaluate
#POST: result of the metric
metricRes_nndist <- function(ppls, celltype, fun){
  metric.res <- list(res = do.call(fun, args = list(pp=ppls[[celltype]], nk = seq(1:15))))
  metric.res$type = celltype
  return(metric.res)
}

#go through all defined celltypes and calculate the nearest-neighbour distance
res_ls <- lapply(celltype_ls, metricRes_nndist, fun = nndistance, ppls = ppls)
#initialise a dataframe for the metric values and the type information
res_df <- data.frame(metric = numeric(0), type = character(0))
# Loop through the res_ls list and combine the metric values with their corresponding type - ChatGPT
for (i in 1:length(res_ls)) {
  metric_values <- res_ls[[i]]$res
  metric_type <- rep(res_ls[[i]]$type, length(metric_values))
  df <- data.frame(metric = metric_values, type = metric_type)
  res_df <- rbind(res_df, df)
}
#plot the densities
p <- ggplot(res_df, aes(x=metric, col= type))+
    geom_density(linewidth=1)+
    scale_x_sqrt() +
    theme_light() +
    ggtitle('Sqrt of the Mean Nearest-Neighbour Distance')
p
```

In the probability-density function of the nearest neighbours the ependymal cells show the shortest nearest-neighbour distances. The OD mature cells have larger nearest neighbour distances and the bimodal distribution indicates a mix of longer and wider distances (which was as well visible in the LISA $L$ function). Microglia cells show the widest distances and the symmetry of the curve indicates similar distances throughout the field of view.

#### DBScan

Often, we are interested which spatial structures build a spatial unit. One way to answer this question is to use spatially aware clustering. 
Here we show one very basic approach, DBScan (density-based spatial clustering with applications for noise). DBScan is an algorithm which uses a parameter called minimal Features. If the number of points per cluster is smaller than the minimal number of features, it is either noise or it is merged with another cluster. Another parameter $\epsilon$ defines the distance at which a point has to lay in order to be part of a cluster. The value of this parameter $\epsilon$ can be determined by an elbow plot, similar to clustering resolution parameters in other algorithms.
from https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-statistics/how-density-based-clustering-works.htm

```{r, cache=FALSE}
pp_df <- as.data.frame(ppls$`OD Mature`)
#determine the correct epsilon neighbourhood
dbscan::kNNdistplot(pp_df, k=5)
```

Given the kNN distance plot we visually detect the "knee" of the curve to be at an distance $\epsilon$ of $200$. This value is needed for the computation of DBScan.

```{r}
#perform DBScan
pp_dbscan <- dbscan::dbscan(pp_df[-3], eps =200, minPts = 5)
plot(pp_df[-3], col = pp_dbscan$cluster)
```

We see that DBScan identifies four clusters. A top cluster in red and two main side clusters in black and green. There is another cluster in blue which is at the top right corner.

another lead to follow in detected spatial clusters is scan statistics with the \texttt{R} package \texttt{rflexscan}.

### Nearest-neighbour function $G$ and empty-space function $F$

#### Definitions of $F$ and $G$ function

Under a stationary spatial point process, the empty-space distance is defined as

$$
d(u,X) = \min\{||u-x_i||: x_i \in X\}
$$

The empty space function is then the cumulative distribution function of the empty-space distances defined above

$$
F(r) = \mathbb{P}\{d(u,X)\leq r\}
$$

The nearest-neighbour distance is defined as

$$
d_i = \min_{j\neq i}||x_j-x_i||
$$

The nearest-neighbour distance distribution function $G(r)$ is then defined as

$$
G(r) = \mathbb{P}\{d(x,X\backslash u \leq r |X\ has\ a\ point\ at\ u\}
$$

For a homogeneous Poisson process, the nearest-neighbour distance distribution is identical to the empty-space function of the same process

$$
G_{pois} \equiv F_{pois}
$$

For a general point process the $F$ and $G$ functions are different

### Empty-space hazard

The $F$ and $G$ functions are, like the $K$ function, cumulative. The same disadvantages as with the $K$ function occur here too. Therefore, an analogue to the pair-correlation function would make sense to consider. For practical reasons this is no longer the derivative of the $F$ function but rather a hazard rate.

$$
h(r) = \frac{f(r)}{1-F(r)}
$$

For a CSR process, the hazard rate is

$$
h_{pois}(r) = 2 \pi \lambda r
$$

Here we use a variance stabilising transformation as suggested by Baddeley et. al. This transformation means that if the process is completely spatial random, the hazard is equal to the intensity $\lambda$.
 <!-- 
```{r}
fhazard_ependymal <- envelope(ppls$Ependymal, Fhazard, nsim=39, fix.n=TRUE,
transform=expression(./(2*pi*r)))
fhazard_ependymal$type <- 'Ependymal'

fhazard_odmature <- envelope(ppls$`OD Mature`, Fhazard, nsim=39, fix.n=TRUE,
transform=expression(./(2*pi*r)))
fhazard_odmature$type <- 'OD Mature'

fhazard_microglia <- envelope(ppls$Microglia, Fhazard, nsim=39, fix.n=TRUE,
transform=expression(./(2*pi*r)))
fhazard_microglia$type <- 'Microglia'

#create a list that combines bove values
fhazard_list<- rbind(fhazard_ependymal, fhazard_odmature, fhazard_microglia)

p <- ggplot(fhazard_list, aes(x=r, y=obs, col= type))+
  geom_line(key_glyph = "point")+
  guides(color = guide_legend(override.aes = list(size = 3))) +
  geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.25, show.legend = FALSE)+
  ggtitle('Empty-space hazard')+
  geom_line(aes(x=r,y=theo),linetype = "dashed", show.legend = FALSE)+
  theme_light() #+ theme(legend.key.size = unit(0.5, "lines"))
p
```
 -->

### $J$-Function

The concepts of the empty-space function $F$ and the nearest-neighbour function $G$ are somewhat complementary. If one decreases, the other increases. A comparison of these two functions as a measure of CSR is the Hopkins-Skellam test (implemented above).

Another approach is the $J$ function.

$$
J(r) = \frac{1-G(r)}{1-F(r)}
$$

"For a homogeneous Poisson process, $F_{pois} \equiv G_{pois}$ such that then $J_{pois} \equiv 1$. Values $J(r) > 1$ are consistent with a regular pattern, and \$J(r) \< 1 is consistent with clustering." (Baddeley et. al.)

```{r, fig.height = 10, fig.width = 7}
### need to redefine the plotting function, because bootstrap is not available for spacing functions ###
#PRE: Celltypes of interest, function to analyse, edge correction to perform
#POST: plot of the metric
plotSpacingMetric <- function(celltype_ls, ppls, fun, x,  edgecorr){
  res_df <- metricResToDF(celltype_ls, ppls, fun)
  #plot the curve
  p <- ggplot(res_df, aes(x=res_df[[x]], y=res_df[[edgecorr]], col= type))+
    geom_line()+
    ylab(edgecorr) +
    xlab(x) +
    ggtitle(paste0(fun, '-function'))+
    geom_line(aes(x=res_df[[x]], y=theo), linetype = 'dashed')+
    theme_light()
  return(p)
}

p_G <- plotSpacingMetric(celltype_ls, ppls, 'Gest', 'r', 'rs')

p_F <- plotSpacingMetric(celltype_ls, ppls, 'Fest', 'r', 'rs')

p_J <- plotSpacingMetric(celltype_ls, ppls, 'Jest', 'r', 'rs')
```

```{r, warning=FALSE, fig.height = 10, fig.width = 7}
p_G/p_F/p_J
```

### Accounting for Inhomogeneity in Spacing Functions

There are inhomogeneous variants of the spacing functions explained above

```{r}
p_G <- plotSpacingMetric(celltype_ls, ppls, 'Ginhom', 'r', 'bord')

p_F <- plotSpacingMetric(celltype_ls, ppls, 'Finhom', 'r', 'bord')

p_J <- plotSpacingMetric(celltype_ls, ppls, 'Jinhom', 'r', 'bord')
```

```{r, cache=FALSE, fig.height = 10, fig.width = 7}
p_G/p_F/p_J
```

Again here, comparing the homogeneous versions of the functions with the inhomogeneous ones reveals, that we seem to solve one problem (inhomogeneity) by assuming correlation stationarity. As this is not given, the inhomogeneous versions don't seem to be accurate. In fact, the homogeneous versions are more easily interpretable than the inhomogeneous alternatives.

### Nearest-Neighbour Orientation

Next to the distance to the nearest-neighbours, we can estimate the orientation of the vector to the nearest-neighbour. This gives an indication of the orientation of the spacing.

```{r}
p <- plotSpacingMetric(celltype_ls, ppls, 'nnorient', 'phi', 'bordm')
p
```

The values of $\phi$ correspond to the orientation of the point pattern. The horizontal axis goes from $180$ to $0$ (left to right) and the vertical from $90$ to $270$ (top to bottom).
We can infer that the orientation of the Ependymal nearest-neighbours is along the vertical axis, OD mature cells don't show a clear pattern and microglial cells a horizontal orientation in their nearest neighbours with a small peak at $\sim 180$ (orientation to the top).

The concept of spacing is not only usable in point pattern analysis but more broadly in any spatial context (e.g. spacing between shapes instead of points).

### Edge Corrections

The same consideration about edge effects as for the $K$ functions have to be made for the spacing functions. The uncorrected estimators are negatively biased as estimators for the real spacing functions. The easiest approach is to draw an artificial border and consider nearest neighbours there in. Other approaches are based on sampling. Yet another approach is based on survival analysis. The idea is that a circle of a point to grows homogeneously with increasing radius until it hits the frame of the window and "dies". This gives survival distributions. This is similar to censored data, where the Kaplan-Meier estimator is the optimal choice.

# Continuous Marks

## Setup

```{r, message=FALSE}
#| label: load-data 2

#subset the data to only look at sample ID 0.01
sub = spe[, spe$sample_id == 0.01]
#sub = spe[, spe$sample_id == 0.01 & spe$cluster_id %in% c("Astrocyte", "Pericytes")]
(pp = .ppp(sub, marks = "cluster_id"))


#subset the data to only look at sample ID 0.01
sub_2CT = spe[, spe$sample_id == 0.01 & spe$cluster_id %in% c("Astrocyte", "Inhibitory")]
#sub = spe[, spe$sample_id == 0.01 & spe$cluster_id %in% c("Astrocyte", "Pericytes")]
(pp_2CT = .ppp(sub_2CT, marks = "cluster_id"))

#split the multitype point process into several single type processes
#fist, set the marks of the point process to be factors
marks(pp) = factor(marks(pp))
ppls = split(pp)
```

```{r, fig.height=15, fig.width=15}
plot(ppls)
```

In `spatstat` a `mark` can basically take any value. It can be discrete as we have seen in the discrete mark chapter or it can take a continuos value, such as gene expression. In our example we take the gene expression of some marker genes from Fig. 6 of the original publication.

```{r}
#  Genes from Fig. 6 of Moffitt et al. (2018)
gex <- as.data.frame(t(as.matrix(assay(sub))))[, c('Slc18a2', 'Esr1', 'Pgr')]
rownames(gex) <- NULL
# gene expression to marks
marks(pp) <- gex
```

> TODO: better plotting?

```{r}
plot(pp)
```

A pairs plot indicates spatial inhomogeneity, i.e. a spatial trend of the of the marks. This plot is only reasonable for a small number of marks however.

```{r}
pairs(as.data.frame(pp), panel = panel.smooth)
```

The `Smooth` command uses cross-validation to select the smoothing bandwidth of the Gaussian kernel. This estimated kernel can be used for visual inspection of the dataset.

```{r}
ppsmooth <- Smooth(pp, bw.smoothppp)
plot(ppsmooth)
```
From the estimated intesity plot we can see that the expression of the marker genes is clearly inhomogeneous.

Nearest-neighbour interpolations uses the nearest mark to measure the intensity at each spatial location. This is conceptually similar to taking a very small bandwith for the Gaussian kernel.

```{r}
plot(nnmark(pp))
```
We can use the average value of neighbouring point to predict the expression of a gene at each point. We can then plot the actual marks versus the fitted values to detect anomalies. E. g. `Esr1` shows a clear half moon shape in the middle of the image, where the actual values are much higher than the fitted. This gives further indication of structure in the gene expression.

```{r}
mfit <- Smooth(pp, bw.smoothppp, at="points")
res <- marks(pp) - mfit

plot(setmarks(pp, res))
```

## Summary functions

As in the discrete case the summary functions assume that the point process is stationary.

### Mark correlation function

The mark correlation function measures the dependence between the marks at two points at distance $r$. It is not a correlation in the classical sense, since it can take any nonegative value. The value of 1 indicates no correlation between the marks. The generalized mark correlation function is given by

$$ k_f(r) = \frac{\mathbb{E}[f(m(u)m(v))]}{\mathbb{E}[f(M,M')]}$$
where $f(m_1,m_2)$ is a test function with two arguments that represent the marks and returns a non-negative value. For continuous non-negative marks the choice of $f$ is by default $f(m_1,m_2)= m_1 m_2$. $M, M′$ represent independent, identically distributed random points with same distribution as the mark of a randomly chosen point. This denominator is chosen such that random marks have a mark correlation of 1.

```{r}
plot(markcorr(pp))
```
We can compare the mark correlation function to a pointwise simulation envelope in which we generate 5 simulations of random labeling.  
```{r}
ppEsr1 <- subset(pp, select = 'Esr1')
markcorr.Esr1 <- envelope(ppEsr1, markcorr, nsim=10)

plot(markcorr.Esr1)
```

The plot indicates that the mark correlation function is significantly different from the random case. The positive association of expression of the Esr1 gene declines with distance. This is consistent with clustering we saw in the residual plot above. 

<!-- We can calculate the cross correlation function between the different gene expression measurments, the diagonal is equivalent to `markcorr` -->

<!-- ```{r} -->
<!-- mc <- markcrosscorr(pp) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- par(mar = c(1, 1, 1, 1)) -->
<!-- plot(mc) -->
<!-- ``` -->

### Mark-weigthed K function

Mark-weigthed K function is a generalization of the K-function in which the contribution of each from each pair of points is weighted by a function of their respective marks. The mark-weighted K-function is given by

$$K_f(r) = \frac 1  \lambda \frac{C_f(r)}{E[ f(M_1, M_2) ]}$$
with the function $C_f(r) = E \left[ \sum_{x \in X} f(m(u), m(x)) 1{0 < ||u - x|| \le r} \;  \big| \; u \in X \right]$ which is equivalent to the unnormalized mark-weighted $K$-function. For every point $u$ we sum the euclidean distance $||u - x||$ of all other points $x$ that are within a distance $r$. This sum is weighted by the function $f$ of the marks of $u$ and $x$. The function is standardized by the expected value of $f(M, M′)$ where $M, M′$ represent independent, identically distributed random points with same distribution as the mark of a randomly chosen point.

In the scenario of random labeling, the mark-weighted $K$-function corresponds to Ripley's $K$-function.    

The default function is $f(m_1, m_2) = m_1 m_2$. 

```{r}
ppEsr1 <- subset(pp, select = 'Esr1')

K.Esr1L <- Kmark(ppEsr1, function(m1,m2) {m1*m2})
plot(K.Esr1L)
```
It is important to note that theoretical value is not very informative since it represents the $K$-function of a Poisson point process and the underlying point process might not be Poisson. Therefore we compare the mark-weighted with its unmarked analogue. 

Here we will compare the $L$-functions, which are the variance stabilized $K$-functions.

```{r}
L.Esr1L <- Kmark(ppEsr1, function(m1,m2) {m1*m2}, returnL = TRUE)
Lest.ppEsr1 <- Lest(ppEsr1, nlarge=7000)
plot(eval.fv(L.Esr1L - Lest.ppEsr1))
```
Like for other functions we can calculate a simulation envelope for the mark-weighted K-function to get confidence intervals.

```{r}
plot(envelope(ppEsr1, fun=Kmark, returnL=TRUE, nsim=50))
```


# Appendix

## Session info

```{r, cache=FALSE}
#| label: session-info
sessionInfo()
```
