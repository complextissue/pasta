# Preamble

## Dependencies

```{r}
#| label: load-libs
#| message: false
#| warning: false
#| results: hide
source("utils.R")
```

## Setup

```{r}
#| label: load-data
spe <- readRDS("../data/spe.rds")
```

# Load data

```{r}
sub <- spe[, spe$sample_id == 0.01]
(pp <- .ppp(sub, marks = "cluster_id"))
```

For simplicity we will mostly look at the three cell types Ependymal, OD Mature and Microglia in this vignette. 

```{r}
marks(pp) <- factor(marks(pp))
selection <- c('OD Mature', 'Ependymal', 'Microglia')

pp_sel <-  subset(pp, marks %in% selection, drop = TRUE)
```


# Visualize 

```{r}
#| fig-width: 10
#| fig-height: 10
plot(pp)
```

<!-- Discrete labels, called "marks", can be extracted with `marks`. -->

<!-- ```{r} -->
<!-- marks(pp)[1:5] -->
<!-- ``` -->

<!-- Marks can be removed from a point pattern with `unmark`. -->

<!-- ```{r} -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 10 -->
<!-- plot(unmark(pp)) -->
<!-- ``` -->

<!-- The marks are now set as a factor. -->

<!-- ```{r} -->
<!-- marks(pp) <- factor(marks(pp)) -->
<!-- ``` -->

<!-- Using `split` a point pattern can be directly split by mark type. -->

<!-- ```{r} -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 10 -->
<!-- ppls <- split(pp) -->
<!-- plot(ppls) -->
<!-- ``` -->

<!-- And with `superimpose` point patterns can be combined.  -->

<!-- ```{r} -->
<!-- do.call(superimpose,ppls) -->
<!-- ``` -->

The summary of `ppp` (point pattern) object returns general properties, plus intensities, combined and per mark type.

```{r}
summary(pp)
```

<!-- If the point pattern has discrete marks, the function `intensity` will return the intensity for each type.  -->
<!-- ```{r} -->
<!-- intensity(pp) -->
<!-- ``` -->

<!-- To get the overall intensity the individual intensities can be summed up. -->

<!-- Assuming that the the multi-type process is first order stationary (i.e. each sub-process is stationary) the individual intensities sum up to the intensity of the unmarked point process. -->

<!-- ```{r} -->
<!-- sum(intensity(pp)) -->
<!-- intensity(unmark(pp)) -->
<!-- ``` -->

The stationarity assumption is not appropriate in all cases. To assess stationarity visually we can plot the kernel density estimates, for all points together or per type.

```{r}
#| fig-width: 5
#| fig-height: 5
plot(density(pp))
```

```{r}
#| fig-width: 10
#| fig-height: 10
ppls <- split(pp_sel) # split by mark
plot(density(ppls))
```

This indicates that our dataset seems to be inhomogeneous, i.e. the different cell types have different intensity functions

If we plot all on the same estimated intensities on the same scale, the very low intensity of Microglia gets obvious.

```{r}
#| fig-width: 10
#| fig-height: 10
plot(density(ppls), zlim = c(0, max(density(ppls))))
```

The relative risk, i.e. the probability of observing a given celltype at a given location, can be calculated with `relrisk`. The bandwidth for smoothing is calculated with `bw.relrisk` and might need to be adjusted.

```{r}
#| fig-width: 10
#| fig-height: 10
rp <- relrisk(pp_sel,se=TRUE)
plot(rp$estimate)
```


```{r, eval=FALSE, echo=FALSE}
im_sum <- im.apply(rp$estimate,sum)
im_sum <- signif(im_sum,9)
all(im_sum==1)
```

Using the `relrisk` function we can get the dominant mark for different regions of the tissue of interest.

```{r, eval=FALSE, echo=FALSE}
#| fig-width: 10
#| fig-height: 10
rpd <- relrisk(pp,diggle = TRUE)
dom <- im.apply(rpd,which.max)
dom <- eval.im(factor(dom,levels=seq_along(levels(unique(marks(pp)))),labels = levels(unique(marks(pp)))))
plot(dom,las=2,main="Dominant mark")
```

# Random labeling

A test of segregation of marks can be performed with `segregation.test`. It is based on the assumption of random labeling and the computed test statistic measures the similarity of the distribution of marks. The randomization is done by permuting the marks of the points while keeping the locations constant.

```{r}
#| warning: false
pp
segregation.test(pp,nsim=19)
```

In this case there is clear indication that the labeling of marks is not random. For more about random labeling check the part in umarked about local scaling.

#TODO: shall we move this part to umarked as well, it goes together with the hotspot analysis

# Measures of spatial segregation

The package `seg` implements different measures of spatial segregation. Spatial segregation measures encompass two distinct concepts. The first describes the evenness versus clustering which is independent of the overall composition of a sample and describes the distribution of individuals. The second describes isolation versus exposure which depends on the overall composition of a sample and describes the degree to which different groups are isolated or exposed to one another.

Spatial segregation measures developped by Reardon and O'Sullivan (2004) [Reardon, S. F. and O'Sullivan, D. (2004) Measures of spatial segregation. Sociological Methodology, 34, 121-162.]. D, R and H measure spatial evenness while P measures the spatial exposure.

- Dissimilarity index (D) describes how different the composition of a local environment is, on average, from the composition of the total population. It ranges from 0 to 1, where 0 indicates perfect integration, and 1 indicates complete segregation.
- Relative diversity (R) is a measure of how much less diverse each individuals local environments are, on average, compared to the total population. It ranges from 0 to 1, where 0 indicates perfect integration, and 1 indicates complete segregation.
- Information theory index (H) is a measure of how much less diverse individuals local environments are, on average, than is the total population. It can be interpreted as a measure of the variation in the diversity of each individuals local environment. It ranges from 0 to 1, where 0 indicates no segregation, and 1 indicates maximum possible segregation, i.e. all subjects in each local environment belong to one group only.
- The spatial exposure index (P) expresses the degree of spatial exposure of group m to group n. It is the average percentage of group n in the local environments of each member of group m and ranges from 0 (no exposure) to 1 (maximal exposure).


```{r}
# create an indicator matrix
model.matrix <- matrix(0, nrow=length(marks(pp_sel)), ncol=length(unique(marks(pp_sel))))
model.matrix[cbind(seq_along(marks(pp_sel)), marks(pp_sel))] <- 1
colnames(model.matrix) <- unique(marks(pp_sel))

spseg(pp_sel,
      data = model.matrix,
      smoothing = 'kernel')
```

How to interpret the spatial exposure index P? Let's look at the documentation of the function.

From `help(spseg)`

> The exposure/isolation index, P, is presented in a matrix form. The spatial exposure of group ‘m’ to group ‘n’ is located in the row ‘m’ and column ‘n’ of the matrix. The matrix is rarely symmetric in practice so the spatial exposure index should be interpreted with care. The spatial isolation index values are given in the diagonal cells of the matrix; cell value at (m, m) indicates the degree of spatial isolation for group ‘m’ for example.


## Spatial Proximity

Index of Spatial Proximity developed by White (1983) [White, M. J. (1983). The measurement of spatial segregation. The American Journal of Sociology, 88, 1008-1018.].

- This numerical value indicates the degree of segregation. A value of 1 indicates evenness in the sample, and values greater than 1.0 indicate clustering. If the index value is smaller than one, it indicates an unusual form of segregation (i.e., some groups are closer to other groups). It compares the average distance between members of one group with that between all individuals, irrespective of group assignment. It may change depend on the definition of distance.

```{r}
# Index of spatial proximity
paste0('Index of spatial proximity: ',
isp(pp_sel,
    data = model.matrix))
```


<!-- ### Example of clear spatial segregation -->

<!-- ```{r} -->
<!-- selection <- c('Astrocyte', 'Ependymal') -->
<!-- pp_sel <-  subset(pp, marks %in% selection, drop = TRUE) -->


<!-- plot(pp_sel) -->

<!-- # create an indicator matrix -->
<!-- model.matrix <- matrix(0, nrow=length(marks(pp_sel)), ncol=length(unique(marks(pp_sel)))) -->
<!-- model.matrix[cbind(seq_along(marks(pp_sel)), marks(pp_sel))] <- 1 -->
<!-- colnames(model.matrix) <- unique(marks(pp_sel)) -->

<!-- spseg(pp_sel, -->
<!--       data = model.matrix, -->
<!--       smoothing = 'kernel') -->

<!-- # Index of spatial proximity -->
<!-- paste0('Index of spatial proximity: ', -->
<!--        isp(pp_sel, -->
<!--            data = model.matrix)) -->
<!-- ``` -->

<!-- ### Example of less segregation -->

<!-- ```{r} -->
<!-- selection <- c('Astrocyte', 'Microglia') -->
<!-- pp_sel <-  subset(pp, marks %in% selection, drop = TRUE) -->


<!-- plot(pp_sel) -->
<!-- plot(unmark(pp_sel)) -->

<!-- # create an indicator matrix -->
<!-- model.matrix <- matrix(0, nrow=length(marks(pp_sel)), ncol=length(unique(marks(pp_sel)))) -->
<!-- model.matrix[cbind(seq_along(marks(pp_sel)), marks(pp_sel))] <- 1 -->
<!-- colnames(model.matrix) <- unique(marks(pp_sel)) -->

<!-- spseg(pp_sel, -->
<!--       data = model.matrix, -->
<!--       smoothing = 'kernel') -->

<!-- # Index of spatial proximity -->
<!-- paste0('Index of spatial proximity: ', -->
<!--        isp(pp_sel, -->
<!--            data = model.matrix)) -->
<!-- ``` -->

# Correlation and spacing

## Distances and nearest neighbors

Investigating the nearest neighbor distance between point for all combinations of marks can be done as follows:

```{r}
d <- nndist(pp_sel,by = marks(pp_sel))
a <- aggregate(d,by = list(from=marks(pp_sel)),min)
a
```

<!-- Another option is to either use the `K` nearest neighbors or count the number of points of a given type with a distance closer than `R`. Both can be done with the function `marktable`, where the argument `R` stands for the neighborhood radius and `N` for number of neighbors. -->

<!-- ```{r} -->
<!-- mt <- marktable(pp_sel,N = 5,collapse = TRUE) -->
<!-- signif(mt/rowSums(mt),2) -->

<!-- mt <- marktable(pp_sel,R = 10,collapse = TRUE) -->
<!-- signif(mt/rowSums(mt),2) -->

<!-- ``` -->

<!-- Additionally the function `markstat` can be used to calculate more complicated expressions than just the sum. -->

## Nearest neighbor correlations

A overall correlation between marks can be calculated with `nncorr`. It returns two values: `unnormalised`, which is the probability that a point and its nearest neighbor have the same type and `normalised`, which divides the unnormalised probability by the probability of random labeling. So a value close to 1 indicates random labeling. A value much larger than 1 means neighboring point are often of the same type. 

```{r}
nncorr(pp_sel)
```

<!-- The R package `spdep` (https://cran.r-project.org/package=spdep) contains many functions to calculate statistics based on nearest neighbors. -->

Another possibility is to work with nearest neighborhood contingency tables to do statistical tests using the `dixon` function from the R package dixon. It allows to calculate the statistic "segregation of species" S which indicates either random labeling (if S=0), attraction (if S<0) or seggregation (if S>0).

```{r}
#| echo: false
out <- dixon(as.data.frame(pp_sel))
out$tablaZ
```


<!-- ### Cuzick-Edwards' k-NN test -->

<!-- ```{r} -->
<!-- # Function to calculate Cuzick and Edwards' T_k statistic for a marked ppp -->
<!-- calculate_Tk_marked <- function(ppp, k_range) { -->
<!--   # Check if the input point pattern is a marked ppp object -->
<!--   if (!is.ppp(ppp) || is.null(marks(ppp))) { -->
<!--     stop("The point pattern must be a marked ppp object.") -->
<!--   } -->

<!--   # Get the unique marks -->
<!--   unique_marks <- unique(marks(ppp)) -->

<!--   # Initialize a data frame to store the T_k statistic for each mark and k -->
<!--   results <- data.frame() -->

<!--   # Calculate the T_k statistic for each mark and k -->
<!--   for (mark in unique_marks) { -->
<!--     # Subset the point pattern by the current mark -->
<!--     ppp_marked <- subset(ppp, marks == mark) -->

<!--     # Separate the cases and controls -->
<!--     cases <- subset(ppp, marks == mark) -->
<!--     controls <- subset(ppp, marks != mark) -->
<!--     # Remark cases and control -->
<!--     marks(cases) <- as.factor('case') -->
<!--     marks(controls) <-  as.factor('control') -->

<!--     # Combine the cases and controls into a single point pattern -->
<!--     combined_ppp <- superimpose(cases, controls) -->

<!--     # Loop through all k's -->
<!--     for (k in k_range) { -->

<!--       # Index of cases -->
<!--       idx <- marks(combined_ppp) == 'case' -->

<!--       # Sum occurrences of cases -->
<!--       T_k <- sum(marktable(combined_ppp, N=k) -->
<!--                  [marks(combined_ppp) == 'case','case']) -->

<!--       # NOT IN ORGINAL FORMULA: divide by total number of points -->
<!--       T_k <- T_k / sum(marks(combined_ppp) == 'case') -->

<!--       # Add the results to the data frame -->
<!--       results <- rbind(results,  -->
<!--                        data.frame(Mark = as.character(mark), -->
<!--                                   K = k, Tk = T_k)) -->
<!--     } -->
<!--   } -->

<!--   # Plot the T_k statistic vs. k for each mark -->
<!--   ggplot(results, aes(x = K, y = Tk, color = Mark)) + -->
<!--     geom_point() + -->
<!--     labs(title = "", -->
<!--          x = "k", -->
<!--          y = "Cuzick and Edwards' T_k statistic", -->
<!--          color = "Mark") -->
<!-- } -->

<!-- # Apply the function to a marked ppp -->
<!-- calculate_Tk_marked(pp_sel, c(1:10)) -->

<!-- plot(split(pp_sel)) -->
<!-- ``` -->

## Summary functions for pairs of types

<!-- ```{r} -->
<!-- # for a faster runtime we will use a subset of the data -->
<!-- selection <- c('Astrocyte', 'OD Mature', 'Ependymal', 'Microglia', 'Pericytes') -->
<!-- pp_sel <-  subset(pp, marks %in% selection, drop = TRUE) -->

<!-- ``` -->

Similar to the simple case without marks it is possible do estimate summary functions. More specifically the summary functions between different marks can be calculated. These summary functions assume that the multitype process is stationary which might not be an appropriate assumption in spatial omcis data, we therefore use inhomogeneous versions of the summary functions.

### Cross K-function

The cross K-function is a summary function that measures the average number of points of type `j` within a distance `r` of a point of type `i`. The formula is given by 

$$
K(r) = \frac{1}{\lambda_j} \mathbb{E} [t(u,r,X^{j})|u \in X^{i}]
$$

where $X^{i}$ is the point pattern of type $i$ and $t(u,r,X^{j})$ is the number of points of type $j$ in a circle of radius $r$ around $u$.

```{r}
Kall <- alltypes(pp_sel, Kcross)
```

First we plot an overview over the cross K function for the different types.

```{r}
#| echo: false
#| message: false
#| results: hide
plotCrossAll <- function(ppp, fun, edgecorr){
  Fall <- alltypes(ppp, fun)
  
  # Create a list of ggplot objects using lapply
  plot_list <- lapply(Fall[["fns"]], function(res) {
    ggplot(res, aes(x = r, y = .data[[edgecorr]])) +
      geom_line(size = 1) +
      geom_line(aes(x = r, y = theo), linetype = "dotted", size = 1) +
      geom_line() +
      labs(title = attributes(res)$yexp) +
      theme_minimal()
  })
  
  p <- wrap_plots(plot_list, nrow = ceiling(length(plot_list)/3), ncol = 3) + 
    plot_layout(guides = "collect") & theme(legend.position='bottom')
  return(p)
}
```

```{r}  
#| fig-width: 15
#| fig-height: 10
plotCrossAll(pp_sel, "Kcross.inhom", "iso")
```

The diagonal of the cross K-function plot shows the K-function for the different marks (indication of Poisson or non-Poisson point processes). Off-diagonal panels give indication of independence of points when the number of points follows the expected K-function but does not imply that the individual marks follow a Poisson process. If the types are independent they are also uncorrelated.

In this overview we can see that there is indication that Microglia and OD Mature cells are independent of each other. The other types seem to be dependent on each other. Let's focus a bit more on the relationship between Ependymal and the other two cell types. We will also calculate confidence intervals for the different cross K-functions.

However, it is important to remember that the cross K-function assumes that the multitype process is stationary. If this is not the case, there is a risk in misinterpreting the results. The problem is confounding between clustering and inhomogeneity. We have already seen that our dataset most likely does not follow the assumption of stationarity. For this reason we will calculate the inhomogneous cross K-function.

```{r}
#| echo: false
#| message: false
#| results: hide
plotCrossMetric <- function(ppp, fun, from, to, edgecorr){
  lce <- lohboot(ppp, fun, from = from, to = to)
  p <- ggplot(lce, aes(x = r, y = .data[[edgecorr]])) +
    geom_line(size = 1) +
    geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.25)+
    geom_line(aes(x = r, y = theo), linetype = "dotted", size = 1) +
    geom_line() +
    labs(title = attributes(lce)$yexp) +
    theme_minimal()
  return(p)
}

p_epen_od <- plotCrossMetric(pp_sel, "Kcross.inhom", "Ependymal", "OD Mature", "iso")
p_epend_micro <- plotCrossMetric(pp_sel, "Kcross.inhom", "Ependymal", "Microglia", "iso")

```
```{r}
# fig-width: 10
# fig-height: 10
p_epen_od + p_epend_micro
```
Remember that the dashed line represents the assumption of a multitype Poisson process. If the line lies above the dotted line there is indication of clustering while if the line is below the dotted line there is indication of repulsion. In the plot above we can see that there is indication of clustering between Ependymal and OD Mature cells while there is indication of repulsion between Ependymal and Microglia cells.

### Cross L-function 
Alternatively the L cross function with similar interpreation can be calculated using the `Lcross` function.

```{r}
#| echo: false
#| message: false
#| results: hide
p_epen_od <- plotCrossMetric(pp_sel, "Lcross", "Ependymal", "OD Mature", "iso")
p_epend_micro <- plotCrossMetric(pp_sel, "Lcross", "Ependymal", "Microglia", "iso")
```
```{r}
# fig-width: 10
# fig-height: 10
p_epen_od + p_epend_micro
```

<!-- ### Cross L-function: -->

<!-- Similiar to the the K-function, the cross L-function can be defined for all pairs of points. -->

<!-- ```{r} -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 10 -->
<!-- lc <- alltypes(pp_sel, Lcross) -->
<!-- plot(lc, .-r~r) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 10 -->
<!-- lce <- alltypes(pp_sel, Lcross, envelope = TRUE, nsim=9) -->
<!-- plot(lce, .-r~r) -->

<!-- ``` -->
<!-- - TODO: not sure why the off-diagonal are not perfectly symmetric -->

<!-- ```{r} -->

<!-- lce <- lohboot(pp_sel, 'Lcross', from = "OD Mature", to = "Ependymal") -->
<!-- lce -->

<!-- edgecorr <- 'iso' -->

<!-- ggplot(lce, aes(x = r, y = .data[[edgecorr]])) + -->
<!--     geom_line(size = 1) + -->
<!--     geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.25)+ -->
<!--     geom_line(aes(x = r, y = theo), linetype = "dotted", size = 1) + -->
<!--     geom_line() + -->
<!--     labs(title = attributes(lce)$yexp) + -->
<!--     theme_minimal() -->
<!-- ``` -->


<!-- ### Cross pair-correlation function -->

<!-- The cross type pair correlation is a genaralization of the pair correlation function to multitype point processes.  -->


<!-- ```{r} -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 10 -->
<!-- pcfc <- alltypes(pp_sel, pcfcross) -->
<!-- plot(pcfc) -->
<!-- ``` -->

### Mark connection function

The mark connection function is essentially the cross pair-correlation function, i.e. the generalization of the of the pair correlation function to multitpye point processes, divided by the unmarked pair-correlation function. It can be interpreted as the conditional probability that two points a distance r apart have labels of type 1 and of type 2, given the presence of those points. 

```{r}
#| fig-width: 10
#| fig-height: 10
plotCrossAll(pp_sel, "markconnect", "iso") + scale_y_continuous(limits = c(0, 1))
```

The dashed lines indicate expected values under random labeling. The values measures dependence or association between the different points. Positive values indicate that nearby points are more likely to have different types than expected by chance. This positive association between different cell types does not necessarily imply dependence, as it could be influenced by a negative association between cells of the same type, as it is the case for the Microglia cells.

### Cross F-function (empty space function), cross G-function (Nearest-neighbor function) and cross J-function

The cross F-function is the cumulative distribution function of the distance from a location to the nearest point of the same type. For each type $i$ it is defined as

$$F_i(r) = \mathbb{P}\{d(u,X^{i}\leq r\}$$.

The cross G-function is the cumulative distribution function of the distance from a location to the nearest point of another type and is defined as

$$G_{ij}(r) = \mathbb{P}\{d(x,X^{(j)} \setminus u \leq r \mid X^{(i)} \ \text{has a point at u})$$.

If the points are independent of each other the G and F function are identical. Both assume that the process is stationary.

There exists a difference in the interpretation of the theoretical values of the K-cross and the G-cross function. For the K-cross the theoretical value indicates independence between the marks while for the G-cross the theoretical value is consistent with the assumption that the points of type `j` are Poisson in addition to being independent of the points of type $i$.

The cross J-function is defined as 

$$J_{ij}(r) = \frac{1-G_{ij}(r)}{1-F_{j}(r)}$$

and summarizes the interpoint dependence between type $i$ and $j$. Under the hypothesis of independent components, i.e. that the point processes of each type are independent the G-function is equivalent to the F-function and the J-function is equal to 1. 

<!-- ### Cross J-function  -->

<!-- The value of 1 is consistent with CSR and independence between different points. -->

<!-- ```{r} -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 10 -->
<!-- jc <- alltypes(pp_sel, Jcross) -->
<!-- plot(jc) -->
<!-- ``` -->

### Dot functions

For each K-, G- and J- function there also exist dot functions which is measuring distances from points of one type to points of any type. These functions allow us to measure the dependence of one mark with all other marks.  For expample, the K-dot function represents the expected number of other point within distance $r$ of a typical point of type $i$. 

```{r}
#| fig-width: 5
#| fig-height: 5
plotCrossAll(pp_sel, "Kdot.inhom", "iso")
```
The dot functions are useful summary statistic to analyse the dependence of one mark with all other marks. 

## Summary function within and between types

In our original dataset we have a large number of different marks. We picked the three OD mature, Ependymal and Microglia for illustrative purposes. An alternative to looking at all cross summary function combinations, it is possible to compare between and within types. An alternative is to compare within and between types.

### Mark equality function

The Mark or Type Equality function for a stationary multitype point process measures the correlation between types of two points separated by distance r. It is the sum of the mark connection function of all pairs of points of the same type.

If k < 1, points at distance r are less likely than expected to be of the same type. If > 1, they are more likely to be of the same type. The value 1 indicates a lack of correlation.

```{r}
#| fig-width: 5
#| fig-height: 5
plotMarkCorr <- function(pp, edgecorr = "iso") {
    me <- markcorr(pp)
    ggplot(me, aes(x = r, y = .data[[edgecorr]])) +
        geom_line(size = 1) +
        geom_line(aes(x = r, y = theo), linetype = "dotted", size = 1) +
        geom_line() +
        labs(title = attributes(me)$yexp) +
        theme_minimal()
}

plotMarkCorr(pp)
```
We can see that in our dataset, it is closer, the more likely it is to find points of the same type.

<!-- ### I-function  -->

<!-- ```{r} -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 10 -->
<!-- ic <- Iest(pp_sel) -->
<!-- plot(ic) -->
<!-- ``` -->

<!-- ## Summary functions for non stationary processes -->

<!-- The cross and dot functions described above assume a underlying stationary point process. If this assumption is not given, the interpretation of the result might be incorrect. -->

<!-- The inhomogeneous equivalents of the described functions require the different intensities as inputs in `spatstat`. If they are not given the intensities are estimated using kernel smoothing.   -->

<!-- ### Inhomogeneous L-function -->
<!-- ```{r} -->
<!-- plot(Lcross.inhom(pp_sel, "Microglia", "OD Mature", sigma=bw.diggle(pp_sel))) -->
<!-- plot(Lcross.inhom(pp_sel, "Microglia", "OD Mature", sigma=bw.relrisk(pp_sel))) -->

<!-- Lcross.inhom(pp_sel, "Microglia", "OD Mature") %>% plot() -->
<!-- ``` -->

# Tests of randomness and independence

In a multitype point process there are two interesting hypothesis:
  - random labeling hypothesis: the allocation of lables to the points is random
  - independent component hyopthesis: there is independence between different type of points
If both statments are correct, the point pattern is considered to be complete spatially random and independent (CSRI), the marked analog to complete spatial randomness (CSR).

## Testing random labelling

Random labeling test is most logical when the marks represents its status, which is not most appropriate assumption when considering cell types. Test for random labeling can be done using permutation test, in which the labels are randomly permuted. Random labeling can be assumed if the permuted datasets are statistically equivalent to the original dataset.

## Testing the indepenence of components assumption

The i to j functions are useful to test the independence of different subprocesses. If the processes of type i and j are independent then
$K_{ij} = \pi r^2, G_{ij}(r) = F_{j}(r),  J_{ij}(r) \equiv 1$. Alternatively, randomization tests can be used in which simulated patterns from the dataset are generated and randomly split into subpatterns. These are then compared to the null hypothesis in which all subpatterns should be statistically equivalent to the original. However, this approach assumes stationarity and there is a need to handle edge effects appearing from random shifts when splitting.

```{r}
#| echo: false
#| message: false
#| results: hide

plotEnvCross <- function(pp, i, j, fun, nsim = 39, radius = 150, global = FALSE){
  pp_scaled <- rescale(pp)
  E1 <- envelope(pp_scaled, fun, nsim=nsim, i=i, j=j,
                 simulate=expression(rshift(pp_scaled, radius = radius)), global = global)
  p <- ggplot(E1, aes(x = r, y = .data[["mmean"]])) +
    geom_line(size = 1) +
    geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.25)+
    geom_line(aes(x = r, y = obs), linetype = "dotted", size = 1) +
    geom_line() +
    labs(title = attributes(E1)$yexp) +
    theme_minimal()
  return(p)
}

pEnv <- plotEnvCross(pp_sel, fun = "Kcross", "Ependymal", "OD Mature", nsim = 39, radius = 150)
```

```{r}
#| fig-width: 5
#| fig-height: 5
pEnv
```

```{r}
#| fig-width: 5
#| fig-height: 5
plotEnvCross(pp_sel, fun = "Kcross", "Ependymal", "OD Mature", nsim = 39, radius = 150, global = TRUE)
```

We have indication that the indepence of components assumption should not be rejected. Therefore we assume that Ependtymal and OD Mature cells are independent.

<!-- # Multitype models and processes -->

<!-- This part will briefly cover the fundamentals of models and processes for multitype point processes. For more details we refer the reader to "Spatial Point Patterns: Methodology and Applications with R" written by Baddeley, Rubak and Turner. -->

<!-- ## Multitype Poisson models -->

<!-- Similar to the unmarked case marked point patterns can be fitted to specific modeling assumptions. The simples case is the homogeneous multitype poisson process. It can be fit again with `ppm` but this time using "marks" as the covariate, which essentially means a different intensity is assumed for each type.  -->

<!-- ```{r} -->
<!-- ppfit <- ppm(pp~marks) -->
<!-- ppfit -->
<!-- ``` -->

<!-- To fit a nonstationary multitype poisson process a additional covariates including the special variables "x" and "y" can be used. For example: -->

<!-- ```{r} -->
<!-- ppfit <- ppm(pp~marks * polynom(x,y,1)) -->
<!-- ppfit -->
<!-- ``` -->

<!-- Multitype Poisson models can be used to test for segregation in a parametric fashion. A Poisson model is considered not segregated or separable when the logarithm of the intensity, log $\log \mu(u, m)$, can be expressed as the sum of two separate terms: $A(u)$ and $B(m)$. The term $A(u)$ solely depends on the location $u$, while the term $B(m)$  depends on the type of point $m$. Any terms that depend on both the location and the type of point $u$ and $m$ indicate segregation. -->

<!-- ```{r} -->
<!-- f0 <- ppm(pp ~ polynom(x,y,3) + marks) -->
<!-- f1 <- ppm(pp ~ polynom(x,y,3) * marks) -->

<!-- anova(f0, f1, test="LR") -->
<!-- ``` -->

<!-- The first model `f0` corresponds to the null hypothesis which assumes an absence of segregation, in which the intercept is different between types but all other coefficients are the same for all types. On the other hand model `f1` corresponds to a segregated model. -->

<!-- ## Multitype Gibbs models -->


<!-- ## Multitype Cox processes -->

<!-- ### Multitype Cluster processes -->

# Appendix

## Session info

```{r}
#| label: session-info
sessionInfo()
```
