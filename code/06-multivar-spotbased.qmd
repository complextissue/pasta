# Preamble

## Dependencies

```{r}
#| label: load-libs
#| message: false
#| warning: false
#| results: hide
source("utils.R")
theme_set(theme_light())
```

## Setup and Preprocessing

```{r}
#| label: load-data
# taken from https://pachterlab.github.io/voyager/articles/visium_10x.html
#spe_vis <- readRDS("../data/spe_spot.rds")
#spe_vis

sfe <- SFEData::McKellarMuscleData(dataset = "full")

sfe <- mirrorImg(sfe, sample_id = "Vis5A", image_id = "lowres")
sfe
sfe_tissue <- sfe[,colData(sfe)$in_tissue]
sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,]

#perform normalisation 
sfe_tissue <- scater::logNormCounts(sfe_tissue)

colGraph(sfe_tissue, "visium") <- findVisiumGraph(sfe_tissue)

weights_neighbourhoods <- colGraph(sfe_tissue, "visium")
```

Given this data from McKellar et al. we choose two genes to analyse henceforth, namels `Mdk`and `Ncl`[7]. 

# Regular Lattice Data

Spot based data is collected along a regular spaced grid where all sample areas have the same size. Such a grid is also called a regular lattice. In more rigorous terms the data $Y$ is the product of a random process but the sampling locations are fixed along a lattice $D$. The lattice $D$ does not have to regular but in the scope of spot based data it is. The main difference of this type of data in comparison to point patterns is, that the locations of the data are then not results of a stochastic process but rather due to a defined sampling strategy [1].

The lattice is composed of individual spatial units

$$
D = \{A_1, A_2,...,A_n\}
$$
where these units are not supposed to overlap

$$
A_i \cap A_j = \emptyset \forall i \neq j
$$

The data is then a random variable of the spatial unit along the lattice

$$
Y_i = Y(A_i)
$$

--> need to find the papers mentioned here!!

A lot of lattice data analysis technique build on the concept of neighbours. Therefore, the spatial relationship has to be modelled with e.g. a spatial weigth matrix $W$. There are a lot of ways to define a spatial weigth matrix $W$. An intuitive way is from Cliff and Ord (1981) and Upton and Fingleton (1985). Here, the units that are adjacent are specified with a one and the ones that are not adjacent with a zero (inary coniguity matrix) [1].

$$
w_{ij} = \begin{cases}
1 \text{ if } A_i \text{ and } A_j \text{ are adjacent}\\
0 \text{ otw}
\end{cases}
$$

other options to specify the weight matrix $W$ are mentioned in [1]. 

# Bi- and Multivariate Data

So far, we have considered methods for univariate data, so where we looked at the change of one variable in several contexts. Spatial methods for bi- and multivariate data exist as well and will be discussed in the following.

## Local Measures for Multivariate Data

### Bivariate Lee's $L$

The implementation in the package `spdep` is as follows:

$$
L(x,y) = \frac{n}{\sum_{i=1}^n(\sum_{j=1}^nw_{ij})^2}\frac{\sum_{i=1}^n(\sum_{j=1}^nw_{ij}(x_i-\bar{x}))(\sum_{j=1}^nw_{ij}(y_j-\bar{y}))}{\sqrt{\sum_{i=1}^nw_{ij}(x_i-\bar{x})^2}\sqrt{\sum_{i=1}^nw_{ij}(y_i-\bar{y})^2}}
$$
(https://r-spatial.github.io/spdep/reference/lee.htmlls)

Lee's $L$ is a bivariate measure that combines non-spatial Pearson Correlation with spatial autocorrelation via Moran's $I$ [3]. Instead of looking at the auto-correlation of one signle variable we can now assess the spatial dependence of two variables.

```{r}
loc <- lee(x = sfe_tissue$nCounts, y = sfe_tissue$nGenes, n = length(sfe_tissue$nCounts), listw = weights_neighbourhoods)

#convert into a plain sf object for plotting
sf <- colGeometries(sfe_tissue)$spotPoly

sf$locEffect <- loc$localL

tm_shape(sf) + tm_fill(col = 'locEffect')  
```

#### Implementation with `Voyager` 

```{r, eval=FALSE}
sfe_tissue <- runBivariate(sfe_tissue, "locallee", swap_rownames = "symbol",
                           feature1 = c('nGenes', 'nCounts'))

plotLocalResult(sfe_tissue, "localG", features = c("nCounts", "nGenes"), ncol = 2,
                colGeometryName = "spotPoly", divergent = TRUE, 
                diverge_center = 0, image_id = "lowres", maxcell = 5e4)
```

### Multivariate local Geary's C

Geary’s C is a measure of spatial autocorrelation that is based on the difference between a variable and its neighbours. It is defined as

$$C_i = \sum_{j=1}^n w_{ij}(z_i-z_j)^2$$

and can be generalized to $k$ parameters by expanding 

$$c_{k,i} = \sum_{v=1}^k c_{v,i}$$

where $c_{v,i}$ is the local Geary’s C for the $v$th variable at location $i$. Compared to bivariates Lee it means that we use more than two variables.

```{r, eval=FALSE}
sfe <- runMultivariate(sfe, type = "localC_multi",
                    subset_row = c("KRT17", "TAGLN"))
```

## VOYAGER

There is a very nice resource explaining in detail the available methods for lattice data (amongst others) (https://pachterlab.github.io/voyager/index.html). We will summarise complement these approaches in this chapter 

# Appendix

## Sources

[1] Zuur, A. F., Ieno, E. N., Smith, G. M., Saveliev, A. A., Mukharamova, S. S., & Zuur, A. F. (2007). Analysis and modelling of lattice data. Analysing Ecological Data, 321-339.

[2] Pebesma, E., & Bivand, R. (2023). Spatial data science: With applications in R. CRC Press.

[3] Lee, S. I. (2001). Developing a bivariate spatial association measure: an integration of Pearson's r and Moran's I. Journal of geographical systems, 3, 369-385.

[4] Ord, J. K., & Getis, A. (2012). Local spatial heteroscedasticity (LOSH). The Annals of Regional Science, 48, 529-539.

[5] Getis, A., & Ord, J. K. (1992). The analysis of spatial association by use of distance statistics. Geographical analysis, 24(3), 189-206.

[6] Anselin, L. (1995). Local indicators of spatial association—LISA. Geographical analysis, 27(2), 93-115.

[7] McKellar, D. W., Walter, L. D., Song, L. T., Mantri, M., Wang, M. F., De Vlaminck, I., & Cosgrove, B. D. (2021). Large-scale integration of single-cell transcriptomic data captures transitional progenitor states in mouse skeletal muscle regeneration. Communications biology, 4(1), 1280.
## Session info

```{r}
#| label: session-info
sessionInfo()
```
