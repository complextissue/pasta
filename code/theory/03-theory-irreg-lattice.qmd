## Spatial weight matrix

One of the challenges when working with (irregular) lattice data is the construction of a [neighbourhood graph](https://r-spatial.org/book/14-Areal.html) [@pebesmaSpatialDataScience2023]. The main question is, what to consider as neighbours, as this will affect downstream analyses. Various methods exist to create neighbours, such as contiguitiy based neighbours (neighbours in direct contact), graph-based neighbours (e.g., $k$-nearest neighbours), distance based neighbours or higher order neighbours [@getisSpatialWeightsMatrices2009; @zuurAnalysingEcologicalData2007; @pebesmaSpatialDataScience2023]. The documentation of the package `spdep` gives an [overview of the different methods](https://r-spatial.github.io/spdep/articles/nb.html).

Segmentation of individual cells is challenging [@wangCellSegmentationImage2019] and construction of contiguity-based neighbours based on individual cell segmentation assumes very accurate segmentation results. Furthermore it would neglect the influence of more distant, not directly adjacent neighbours, which based on the feature of interest might not be the correct assumption.

In an irregular lattice, the task of finding a spatial weight matrix is more complex, as different options exist. One option is to base the neighbourhood graph on neighbours that are in direct contact with each other (contiguous), as implemented in the `poly2nb` method. As cell segmentation is notoriously imperfect, we add a `snap` value, which means that we consider all cells with distance 20 or less as contiguous.

```{r}
colGraph(sfe, "poly2nb") <-
  findSpatialNeighbors(sfe,
    type = "cellSeg",
    method = "poly2nb", # wraps the spdep function with the same name
    style = "W",
    snap = 20 # all cells with less distance  apart are considered contiguous
  )
```


```{r}
p1 <- plotColGraph(sfe,
  colGraphName = "poly2nb",
  colGeometryName = "cellSeg",
  bbox =  c(xmin = 3500, xmax = 10000, ymin = 157200, ymax = 162200)
) + theme_void()
```

Alternatively, we can use a k-nearest neighbours approach. The the number $k$ is somewhat arbritary.

```{r}
colGraph(sfe, "knn5") <-
  findSpatialNeighbors(sfe,
    method = "knearneigh", # wraps the spdep function with the same name
    k = 5,
    zero.policy = TRUE
  )
```

```{r}
p2 <- plotColGraph(sfe,
  colGraphName = "knn5",
  colGeometryName = "cellSeg",
  bbox = c(xmin = 3500, xmax = 10000, ymin = 157200, ymax = 162200)
) + theme_void()
```

As we can see below, the graphs look quite distinct. On the left side, in the contiguous neigbhbour graph (neighbours in direct contact) we can notice the formation of patches, while in the knn graph isolated patches are more interconnected.

```{r}
#| fig-width: 15
#| fig-height: 10
p1 + p2
```

<!-- > Thought: if we assume non perfect segmentation we could basically calculate the same statistics also on point pattern derived datasets. We would also use a k-nearest neighbours approach in a "point pattern" dataset. The centroids of the cells as a proxy for the spatial location. -->

<!-- > Is there a good methods to dermine a good neighbourhood matrix? -->

<!-- > Point pattern as a "event based" dataset, lattice data an "observation" based dataset. -->