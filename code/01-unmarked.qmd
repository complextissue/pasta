# Preamble

## Dependencies

```{r}
#| label: load-libs
#| message: false
#| warning: false
#| results: hide
source("utils.R")
```

## Setup

```{r}
#| label: load-data
spe <- readRDS("../data/spe.rds")

#subset the data to only look at sample ID 0.01
sub <- spe[, spe$sample_id == 0.01]
(pp <- .ppp(sub, marks = "cluster_id"))

#split the multitype point process into several single type processes
#fist, set the marks of the point process to be factors
marks(pp) <- factor(marks(pp))
ppls <- split(pp)
```

If not otherwise indicated, all information was taken from Baddeley et al. - Spatial Point Patterns.

```{r, fig.width=12, fig.height=12}
#Plot the entire point process where the marks are overlayed
plot(unmark(pp), main = 'Point Pattern Unmarked')
#Plot the marks separately 
plot(ppls, main = 'Point Pattern Marks Seperated')
```

# Concepts and Definitions of Point Processes

## Point Process

```{r}

```

## Complete Spatial Randomness

Complete spatial randomness (CSR) is the null model of point patterns, being the result of a poisson process. A completely random process is characterised by two properties

### Homogeneity

Homogeneity means that the expected number of points falling into a given region $B$ is proportional to its area $|B|$ given a proportionality constant $\lambda$. The constant $\lambda$ is the intensity of the process, so the average number of points in a unit area.

$$
\mathbb{E}[X\cap B] = \lambda |B|
\label{eq:expected_number_points}
$$

### Independence

Independence means that in two regions $A$ and $B$ the number of points $n(X\cap A)$ and $n(X\cap B)$ are two independent random variables. That means the number of points in region $A$ does not affect the number of points in region $B$. The number of points follow a poisson distribution:

$$
\mathbb{P}[N=k] = e^{-\mu}\frac{\mu^k}{k!}\\
\label{eq:poisson_process}
$$

## Inhomogeneous Poisson Process

A poisson process that is spatially varying in its average density of points is called inhomogeneous. Here, the average density $\lambda(u)$ is a function of spatial location $u$. The expected number of points falling into a region $B$ is 

$$
\mu = \int_{B} \lambda(u)du 
\label{eq:expected_number_inhomogeneous}
$$

## Stationarity

"A point process is called stationary if, when we view the process through a window $W$, its statistical properties do not depend on the location of the window in two-dimensional space."

## Isotropy

A point process is called isotropic, if its statistical properties are invariant to rotations. A CSR process is both stationary and isotropic.

## Intensity

Intensity is the expected density of points per unit area, as seen above. It can be interpreted as the rate of occurrence or the abundance of events recorded. The intensity itself is called a first moment property - being related to the expected number of points.

### Estimating Intensity

The intensity can be estimated regardless of the type of the point pattern. In order to do so, we sum the individual intensities of the marks

```{r}
intensityPointProcess<- function(pp,mark){
  if(mark == TRUE){
    return(intensity(pp))
  }
  else{
    return(sum(intensity(pp)))
  }
}

intensityPointProcess(pp,mark=FALSE)
```

else we can look at each mark individually

```{r}
intensityPointProcess(pp,mark=TRUE)
```
#### Quadrat Counting

quadrat counting can again be performed for the entire picture

```{r, fig.width=12, fig.height=12}
Q5 <- quadratcount(pp, nx=5, ny=5)
plot(unmark(pp), main='Unmarked Point Pattern Quadrats')
plot(Q5, col='black', add=TRUE)
```

or for each type separately, treating each type as an unmarked process

```{r, fig.width=12, fig.height=12}
Q5sep <- quadratcount(ppls, nx=5, ny=5)
plot(Q5sep, main = 'Separated Marks Quadrats')
#plot(ppls, add=TRUE)
```

The quadrat counts can be tested against regularity. This can happen again in the unmarked pattern or in the separated types

```{r}
quadratTestPointProcess <- function(pp, mark){
  if(mark==TRUE){
    return(lapply(split(pp), quadrat.test, 5, alternative="regular", method="MonteCarlo"))
  }
  else{
    return(quadrat.test(unmark(pp), 5, alternative="regular", method="MonteCarlo"))
  }
}
quadratTestPointProcess(pp, mark=FALSE)
```
#### Kernel Estimation

```{r, fig.width=12, fig.height=12}
Dens <- density(pp)
plot(Dens, main = 'Kernel Density')
```

```{r, fig.width=12, fig.height=12}
Denssep <- density(ppls)
plot(Denssep, main = 'Kernel Density Separated Marks  ')
```

#### Summarising Functionality for Estimating Intensity

```{r, eval=FALSE}
#PRE:
#POST:
estimatingIntensity <- function(
  pp
  method = c('expectation', 'quadrat', 'kernel', 'density', 'adaptive-density'),
  homogeneous = FALSE,
  nx = NULL,
  ny = NULL,
  correction = c(),
){

}
```

```{r}

```

### Testing for CSR

```{r}
#PRE: takes a point process and the indication, which test for CSR should be performed and potentially a covariate
#POST: returns if a point process or its individual point process marks are CSR or not.
#TODO: Change maybe to a switch statment in terms of computing time; Change lapply to mclapply later on
#TODO: There is a conceptual mistake - we pull out marks and test them against a markov simulation. It should rather be to test against all the other cells
testingCSR <- function(
    pp,
    method = c('quadrat','cdf','bermans','clark-evans','hopkins-skellam'),
    mark = FALSE,
    covariate = NULL,
    test = c('ks', 'cvm', 'ad'),
    verbose = FALSE
){
  #perform a quadrattest for individual marks or for the entire pointprocess
  if(method == 'quadrat'){
    if(mark == TRUE){
      test.result <- lapply(split(pp), quadrat.test, 5, method="MonteCarlo")
    }
    else{
      test.result <- quadrat.test(unmark(pp), 5, method="MonteCarlo")
    }
   }
  #perform a cdftest for individual marks or for the entire pointprocess given a covariate
  else if(method == 'cdf' && !is.null(covariate)){
    if(mark == TRUE){
      test.result <- lapply(split(pp), cdf.test, covariate, test=test)
    }
    else{
      test.result <- cdf.test(unmark(pp), covariate, test=test)
    }
  }
  #perform a bermans test for individual marks or for the entire pointprocess
  else if(method == 'bermans' && !is.null(covariate)){
     if(mark == TRUE){
      test.result <- lapply(split(pp), berman.test, covariate, test='Z1')
    }
    else{
      test.result <- berman.test(unmark(pp), covariate, test='Z1')
    } 
  }
  #perform a clark evans test for individual marks or for the entire pointprocess
  else if(method == 'clark-evans'){
     if(mark == TRUE){
      test.result <- lapply(split(pp), clarkevans.test)
    }
    else{
      test.result <- clarkevans.test(unmark(pp))
    } 
  }
  #perform a hopkins-skellam test for individual marks or for the entire pointprocess
  else if(method == 'hopkins-skellam'){
     if(mark == TRUE){
      test.result <- lapply(split(pp), hopskel.test)
    }
    else{
      test.result <- hopskel.test(unmark(pp))
    } 
  }
  #base case of the "switch" statement
  else{
    print("ERROR: non-specified arguments or methods")
    return(NULL)
  }
  
  #summarise the results as a mask of booleans to indicate which structures are 
  #random and which are not
  if(mark==TRUE){
    p.value.mask <- lapply(test.result, function(x) x$p.value>0.05)
  }
  else{
    p.value.mask <- test.result$p.value>0.05
  }
  #return the values of the test calculations, either just the boolean if 
  #CSR or not or the entire test statistics
  if(verbose == TRUE){
    return(test.result)
  }
  else{
    return(p.value.mask)
  }
}
result <- testingCSR(pp,method='clark-evans',mark=TRUE, verbose=FALSE)

testingCSR(ppls$Ependymal, method='clark-evans')
testingCSR(ppls$Microglia, method='clark-evans')
```

## Correlation

Correlation or more generally covariance is called a second order quantity and measures dependence between data points. In point processes 

### Morisita Index

### Nearest Neighbour approaches

Nearest neighbour methods center around the notion of a nearness. In this section, we introduce `nndist`, a method to calculate the distances until $k$ nearest neighbours are found. This information is summarised as a histogram. In order to distill more information from this nearest-neighbour distance histogram, we follow the approach from the function `nnclean` and fit a Gamma mixture model to the data. The number of mixture components can be set individually. We choose a value of $k=2$ to model close range interactions and long range interactions. This gives us parameteric models for our histogram of nearest-neighbour distances. The aim would be to compare these parameteric models via statistical tests such as Anderson-Darling or Kolmogorov Smirnov. Another idea would be to compute the distance between these models with e.g. a Kullback-Leibler Divergence.

```{r}
nearestNeighbourCleaning <- function(pp, mark){
  if(mark==TRUE){
    return(lapply(split(pp), nnclean, k=10, plothist = TRUE))
  }
  else{
    return(nnclean(pp, k=10, plothist = TRUE))
  }
}
#as a histogram this fits a mixture model with 2 (?) gamma distributions one representing cluster feature and one representing noise. They add the probability of belonging to this very gamma distribution to get better (?) separation of the two curves
nearestNeighbourCleaning(ppls$Ependymal, mark=FALSE)
nearestNeighbourCleaning(ppls$`OD Mature`, mark=FALSE)

# potentially easier to just calculate the distances to a nearest neighbour and plot the hist and fit a mixture model - difficult to set the number of components in that case 
nndistances_k10_ependymal <- nndist(ppls$Ependymal, k = 5)
nndistances_k10_microglia <- nndist(ppls$`OD Mature`, k = 5)
hist_ependymal <- hist(nndistances_k10_ependymal, breaks = 50, plot = FALSE)
hist_microglia <- hist(nndistances_k10_microglia, breaks = 50, plot = FALSE)

#fit now a gamma mixture model to this nndist data
gamma_mm_comp2_ependymal <- mixR::mixfit(nndistances_k10_ependymal, ncomp=2,family = 'gamma')
gamma_mm_comp2_microglia <- mixR::mixfit(nndistances_k10_microglia, ncomp=2,family = 'gamma')

#plot this
c1 <- rgb(173,216,230,max = 255, alpha = 100, names = "lt.blue")
c2 <- rgb(255,192,203, max = 255, alpha = 100, names = "lt.pink")

plot(hist_ependymal, col = c1, main = "Histogram of Ependymal and OD Mature Cells", freq=FALSE)
legend(400, 95, legend=c("Ependymal", "Microglia"),
       col=c(c1,c2), lty=1:2, cex=0.8)
lines(density(gamma_mm_comp2_ependymal),col='blue')
plot(hist_microglia, col = c2, add = TRUE, legend=c("Ependymal", "OD Mature"),freq=FALSE)
lines(density(gamma_mm_comp2_microglia),col='red')
```

# Appendix

## Session info

```{r}
#| label: session-info
sessionInfo()
```
